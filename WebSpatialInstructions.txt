// File: index

# WebSpatial Handbook

## Overview

It's recommended to read these docs in order, especially the first three chapters:

1. [**Introduction**](/docs/introduction): Introduces the problems WebSpatial solves and the benefits it brings.
2. [**Quick Example**](/docs/quick-example): Use a minimal example to get a quick feel for the actual results and development experience of the WebSpatial SDK.
3. [**Core Concepts**](/docs/core-concepts): Learn the fundamental concepts of [Spatial Apps](/docs/core-concepts/shared-space-and-spatial-apps) and the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial).

The fourth chapter provides comprehensive and detailed [**Development Guide**](/docs/development-guide). The guide consists of three parts, structured for both sequential reading and quick reference:

1. [What web projects can use WebSpatial API](/docs/development-guide/web-projects-that-support-webspatial).
2. How to [add the WebSpatial SDK](/docs/development-guide/enabling-webspatial-in-web-projects) to your web projects, [use WebSpatial Builder for visionOS testing](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps) (simulator or device), and how to bring spatial features to your site while still [keeping it a standard, cross-platform website](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools).
3. How to [use the WebSpatial API](/docs/development-guide/using-the-webspatial-api) ([Spatialization](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements), [Material](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds), [Elevation](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements), [Scenes](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes), [3D](/docs/development-guide/using-the-webspatial-api/add-3d-content)) in web projects where the SDK is already integrated.

There are currently two sample projects:

1. One is the [Quick Example](/docs/quick-example) itself, which you can build it from scratch, or just grab the ready-made version from [the repo](https://github.com/webspatial/quick-example). There's also a [video](https://youtu.be/ddBBDBq7nhs) showing the full setup process.
2. The other is the ["techshop" demo](https://github.com/webspatial/sample-techshop), showcases more realistic spatial UI design and also demonstrates [cross-platform functionality](/docs/introduction/built-on-the-existing-web-ecosystem#example-techshop).

## Feedback & Support

<!-- :::warning -->

The WebSpatial SDK is newly open-sourced and may have bugs or missing docs/examples. If you run into issues, don't spend too much time trying to fix them yourself, just share sample code with us on [Discord](https://discord.gg/nhFhSuhNF2) or [GitHub Issues](https://github.com/webspatial/webspatial-sdk/issues). That way, we can quickly assess the problem and offer a solution, suggestion, or hotfix.

<!-- ::: -->

## Table of Contents

<div className="blackLink">

1. [Introduction](/docs/introduction)
   - [New Powers for XR Apps](/docs/introduction/new-powers-for-xr-apps)
   - [The New Generation of Spatial Apps](/docs/introduction/the-new-generation-of-spatial-apps)
   - [HTML/CSS and WebXR](/docs/introduction/html-css-and-webxr)
   - [Make the Web Spatial Too](/docs/introduction/make-the-web-spatial-too)
   - [Built on the Existing Web Ecosystem](/docs/introduction/built-on-the-existing-web-ecosystem)
   - [If You Are a \_\_\_ Developer](/docs/introduction/if-you-are-a-developer)
2. [Quick Example](/docs/quick-example)
3. [Core Concepts](/docs/core-concepts)
   - [Shared Space and Spatial Apps](/docs/core-concepts/shared-space-and-spatial-apps)
   - [Unique Concepts in WebSpatial](/docs/core-concepts/unique-concepts-in-webspatial)
   - [Scenes and Spatial Layouts](/docs/core-concepts/scenes-and-spatial-layouts)
   - [Spatialized Elements and 3D Container Elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements)
   - [Full Space and AR Capabilities](/docs/core-concepts/full-space-and-ar-capabilities)
4. [Development Guide](/docs/development-guide)
   - [Web Projects That Support WebSpatial](/docs/development-guide/web-projects-that-support-webspatial)
     - [Creating New Web Projects](/docs/development-guide/web-projects-that-support-webspatial/creating-new-web-projects)
   - [Enabling WebSpatial in Web Projects](/docs/development-guide/enabling-webspatial-in-web-projects)
     - [Prerequisite: Become a (Minimal) PWA](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa)
       - [Add Icon Files](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-icon-files)
       - [Add Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest)
     - [Step 1: Install the WebSpatial SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk)
     - [Step 2: Add Build Tool for Packaged WebSpatial Apps](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps)
       - [Options of the WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder)
       - [(Optional) Simplify WebSpatial Builder Using dotenv](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/optional-simplify-webspatial-builder-using-dotenv)
     - [Step 3: Integrate WebSpatial SDK into Web Build Tools](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools)
       - [Configure JS/TS Compiler](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/configure-js-ts-compiler)
       - [Add Optimizations and Defaults to Web Build Tools](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools)
       - [Generate a WebSpatial-Specific Website](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website)
       - [Check if Running in WebSpatial Mode](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode)
   - [Using the WebSpatial API](/docs/development-guide/using-the-webspatial-api)
     - [Spatialize HTML Elements](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements)
     - [Add Material Backgrounds](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds)
     - [Elevate 2D Elements](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements)
     - [Manage Multiple Scenes](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes)
     - [Add 3D Content](/docs/development-guide/using-the-webspatial-api/add-3d-content)

</div>

---

// File: core-concepts/shared-space-and-spatial-apps

# Shared Space and Spatial Apps

## Shared Space {#shared-space}

The [spatial-computing architecture introduced by visionOS](#unified-rendering) provides a brand-new app runtime environment called **Shared Space**.

A Shared Space is a [Mixed Reality](https://developer.picoxr.com/document/web/introduce-vr-mr-ar/) 3D environment that matches the physical space around you.

Within this single 3D space, multiple apps can coexist harmoniously - they fit naturally into the real-world environment and with one another.

These **Multitasking Apps** include not only traditional 2D apps but also **Spatial Apps** that take advantage of 3D space and contain 3D content.

| <Image img={require("/assets/concepts/1-1.png")} alt="Scene Example 1" /> | <Image img={require("/assets/concepts/1-2.jpg")} alt="Scene Example 1" /> |
| :-------------------------------------------------------: | :-------------------------------------------------------: |

## Spatial Apps {#spatial-apps}

Inside a Shared Space, an app's content is no longer confined to the plane of a 2D window; it **can extend into the 3D space in front of that plane**. In addition to X and Y, content's positioning and layout now incorporate a true Z-axis.

Content is no longer limited to 2D window containers. It can be placed in spatial containers that **have volume**, similar to 3D bounding boxes.

An app can be made up of [multiple such content containers](/docs/core-concepts/scenes-and-spatial-layouts), all of which are [**managed uniformly by the spatial-computing OS**](/docs/core-concepts/scenes-and-spatial-layouts#spatial-layout).

Many 2D UI elements that make up the content can be **[spatialized](/docs/core-concepts/spatialized-elements-and-3d-container-elements)**, meaning they enter 3D space where they can be positioned, laid out, and transformed.

You can also use [3D UI elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements#3d-elements) to build richer, more flexible and fully-featured 3D content. These 3D elements can **be laid out together with 2D UI elements** along the X, Y, and Z axes, creating more sophisticated **mixed 2D-and-3D** UI components.

This kind of app is called a **Spatial App**.

Spatial Apps are the [new generation of XR apps](/docs/introduction/the-new-generation-of-spatial-apps). They **preserve the strengths of 2D apps** from desktop and mobile platforms while gaining **optional, progressive [spatial enhancements](/docs/introduction/new-powers-for-xr-apps)** on spatial-computing platforms.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/concepts/1-3.png")} alt="Spatial App Example 1" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/concepts/1-4.jpg")} alt="Spatial App Example 2" />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/concepts/1-5.jpg")} alt="Spatial App Example 3" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/concepts/1-6.jpg")} alt="Spatial App Example 4" />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/concepts/1-7.jpg")} alt="Spatial App Example 5" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/concepts/1-8.jpg")} alt="Spatial App Example 6" />
  </div>
</div>

:::info
Example apps shown above:

- https://apps.apple.com/us/app/globes/id6480082996
- https://apps.apple.com/us/app/astronoma/id6502267850
- https://apps.apple.com/us/app/museas/id6496682427
- https://apps.apple.com/ca/app/art-universe/id6474541827
- https://apps.apple.com/us/app/calendar-schedule-day-peek/id6477632294
- https://apps.apple.com/us/app/numerics-track-your-metrics/id875319874?platform=vision

:::

## Unified Rendering {#unified-rendering}

Unlike traditional XR apps, spatial apps don't have to rendering their own content or build full XR interactions. Instead, the OS that provides the Shared Space offers a unified rendering service and handles fundamental natural interactions (for example, [gaze and hand interaction](/docs/core-concepts/spatialized-elements-and-3d-container-elements#nature-interaction)).

Multiple Spatial Apps can **blend into a single coordinate system and lighting environment** inside the Shared Space, complete with positional relationships, occlusion, shadows, and more.

Because of this, Spatial Apps cannot freely build independent rendering pipelines. Instead, they expose content through OS-managed 2D/3D containers called **[Scenes](/docs/core-concepts/scenes-and-spatial-layouts)** and describe that content via [APIs the OS understands](/docs/core-concepts/spatialized-elements-and-3d-container-elements). This **lets the OS understand and manage apps' content**, enabling **Unified Rendering**.

:::info
[Unified Rendering App Model](https://developer.picoxr.com/news/multi-app-rendering/):

<Image img={require("/assets/concepts/1-9.jpg")} alt="image" />

Unified rendering architecture on visionOS:

<Image img={require("/assets/concepts/1-10.jpg")} alt="image" />

Excerpts from the WWDC session on unified rendering:

<Image img={require("/assets/concepts/1-11.jpg")} alt="image" />
<Image img={require("/assets/concepts/1-12.jpg")} alt="image" />
<Image img={require("/assets/concepts/1-13.jpg")} alt="image" />
:::

---

// File: core-concepts/unique-concepts-in-webspatial

# Unique Concepts in WebSpatial

## WebSpatial App {#webspatial-app}

Mainstream Web content today is confined to flat pages. In the [Shared Space](/docs/core-concepts/shared-space-and-spatial-apps) it can only exist as a **pure 2D app** and [lacks spatial APIs and the ability to use 3D space](/docs/introduction/html-css-and-webxr#html-css).

Content built with the WebXR API can access 3D space, but because it handles XR interaction itself and relies on low-level graphics APIs (WebGL and later WebGPU) to render independently, the operating system cannot ["understand"](/docs/core-concepts/shared-space-and-spatial-apps#unified-rendering) it. For this reason, WebXR content currently cannot become a [**multitasking app** inside the Shared Space](/docs/core-concepts/shared-space-and-spatial-apps).

When a 2D webpage inside the Shared Space launches a WebXR session, that session takes over the entire space. It replaces the Shared Space, cannot coexist with other apps, and cannot even coexist with the webpage's own 2D window.

A **WebSpatial App** is a type of multitasking [Spatial App](/docs/core-concepts/shared-space-and-spatial-apps#spatial-apps) that works inside the Shared Space. It inherits all mainstream Web APIs (HTML, CSS, JS, and standard Web APIs) and adds the minimal set of new spatial APIs - the **[WebSpatial API](#webspatial-api)**. By combining these new and existing APIs, a WebSpatial App can describe mixed 2D-and-3D content in a way the operating system can understand and [render uniformly](/docs/core-concepts/shared-space-and-spatial-apps#unified-rendering) inside the Shared Space.

**Ideally**, a WebSpatial App should combine the strengths of Web and native apps: it can run on demand without installation via a URL, yet it [can also be installed, integrate tightly with the OS](https://web.dev/explore/progressive-web-apps), and be [distributed through app stores](https://www.pwabuilder.com/).

## WebSpatial API {#webspatial-api}

This set of new spatial APIs is called the **WebSpatial API**.

To stay connected with mainstream Web development and preserve existing content, the WebSpatial API isn't a brand-new, standalone API - it's **an extension of the existing 2D web APIs**.

For 2D content, the WebSpatial API does not introduce new UI elements. Instead, it lets existing HTML elements can be **[spatialized directly](/docs/core-concepts/spatialized-elements-and-3d-container-elements)**.

When positioning elements in 3D space, the API reuses the **existing CSS layout features on the X and Y axes** (absolute positioning, CSS transforms, and so on) and only [adds new CSS API when working with the Z axis](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements).

The WebSpatial API introduces [3D content container elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements#3d-elements) that HTML never had. These containers behave like `<img>`, `<video>`, or `<canvas>`: they can be laid out with other 2D elements and are positioned in 3D space using the same spatial API.

Through `window.open`, `<a target="_blank">`, and other [existing new-window APIs](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes), the WebSpatial API manages an app's [scene containers](/docs/core-concepts/scenes-and-spatial-layouts).

## WebSpatial SDK {#webspatial-sdk}

There are two main hurdles to providing the [WebSpatial API](#webspatial-api) in browser engines: First, it takes a long time to get these APIs standardized through web standards communities and committees. Second, on platforms like visionOS, only the system's default WebView is available, leaving no room to customize the browser engine.

On the other hand, although HTML and CSS sit at the foundation of Web development, most web developers do not use them directly to build web apps. Instead, they use **UI or application frameworks** - today React is the most popular. Developers author HTML via JSX and React components and style via Tailwind CSS, PostCSS, or CSS-in-JS.

So, to quickly enable these APIs for real-world use and meet urgent needs on the web, the WebSpatial open-source project provides a **WebSpatial SDK tailored for Web frameworks** (such as React), without needing to modify browser engines. This allows web developers to start [using the WebSpatial API immediately within their UI framework's HTML (JSX) and CSS APIs](/docs/introduction/built-on-the-existing-web-ecosystem).

After a Web project is compiled by a build tool like Vite, the output is **Web code tailored for spatial-computing platforms**. A native Spatial App called the **WebSpatial App Shell** loads and runs that code in a **Web Runtime (like the system's default WebView)**. A **non-standard JS bridge API** injected into the WebView lets the Web code communicate with the App Shell. The Web Runtime still renders 2D content, while the App Shell uses native spatial capabilities to spatialize that 2D content and render 3D content.

This hybrid approach enables a **standards Web App (a [PWA](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa))** to gain spatial capabilities and user experience comparable to a native Spatial App **starting today**.

The **WebSpatial SDK** has two main parts.

- **Runtime layer** – Framework-specific SDKs such as the **[React SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#react-sdk)** expose WebSpatial APIs at runtime. These framework SDKs are built on the lower-level **[Core SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#core-sdk)**, a framework-agnostic JS library.

- **Build layer** – Because the WebSpatial SDK relies on an WebSpatial App Shell for spatial capabilities, the SDK provides **[WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps)**. This tool packages a **Packaged WebSpatial App** for a specific spatial-comupting platform, such as a visionOS app bundle. The package includes the platform-specific WebSpatial App Shell that launches the Web Runtime (system WebView) to load and run the web build output. The resulting app can be installed on the platform-specific simulator or real device and submitted to the corresponding app store.

:::tip
WebSpatial Builder also supports [offline-packing the Web build output into the native app bundle](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url). In that mode the WebSpatial App Shell loads the Web files locally and offline instead of from a web server. The app is not a website and loses cross-platform reach and URL sharing, but still benefits from the Web development ecosystem and tooling.
:::

If the upcoming **WebSpatial Browser** app (currently under development) has been pre-installed on the target platform, there is no need to package, install, or publish the app to app stores. Since the WebSpatial Browser already contains the WebSpatial App Shell, so you can open any WebSpatial App URL directly in it and experience it in spatial form.

<Image img={require("/assets/concepts/2-1.jpg")} alt="Scene Example 2" />

---

// File: core-concepts/scenes-and-spatial-layouts

# Scenes and Spatial Layouts

## Scenes {#scenes}

A [spatial app](/docs/core-concepts/shared-space-and-spatial-apps#spatial-apps) is composed of **Scenes**.

A Scene is a content container centrally managed by the spatial-computing OS. Every piece of app content must live in one or more of these containers.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/concepts/3-1.png")} alt="Scene Example 1" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/concepts/3-2.png")} alt="Scene Example 2" />
  </div>
</div>

### Window Scene {#scenes-window}

The most basic **Scene type** is the **Window**.

<Image img={require("/assets/concepts/3-3.jpg")} alt="Scene Example 3" />

Unlike a flat window in the desktop operating systems, a Window Scene can host both 2D and **3D content**. All content is positioned **based on the window plane** and can extend into **the 3D space in front of it**.

<Image img={require("/assets/concepts/3-4.jpg")} alt="Scene Example 3" />
<Image img={require("/assets/concepts/3-5.jpg")} alt="Scene Example 3" />

A Window Scene has a new capability: its background and borders can be fully transparent, making the content **appear to float independently in space**.

<Image img={require("/assets/concepts/3-6.jpg")} alt="Scene Example 3" />
<Image img={require("/assets/concepts/3-7.jpg")} alt="Scene Example 3" />

### Volume Scene {#scenes-volume}

A spatial app can also use a more 3D scene type called a **Volume Scene** (also referred to as a **volumetric window**, or **volume**).
This scene is a bounded local 3D space (a sort of 3D bounding box) that has volume. It can also hold 3D content and **2D content**.

<Image img={require("/assets/concepts/3-8.jpg")} alt="Scene Example 3" />

Although both Window Scenes and Volume Scenes can host 2D and 3D content, the former behaves like a **panel with depth extending forward**, while the latter behaves like a bounded **object** with full volume. The OS treats them differently within the shared space, integrates them with the environment in distinct ways, and exposes different interactions, for example separate drag behaviors and [Spatial Layout](#spatial-layout) modes.

<Image img={require("/assets/concepts/3-9.jpg")} alt="Scene Example 3" />
<Image img={require("/assets/concepts/3-10.jpg")} alt="Scene Example 3" />

### Scenes in a WebSpatial App {#scenes-in-webspatial}

A WebSpatial app is composed of the same Scene containers.

At the same time, each Scene acts as a container that loads a URL, parses, and runs an HTML page - much like a browser window. **All scene content comes from the webpage loaded inside it.**

Unlike browser windows, Scenes from different WebSpatial apps aren't managed like multiple windows or tabs inside a single browser app. Each WebSpatial app owns one or more Scenes independently, just like a native spatial app.

<Image img={require("/assets/concepts/3-11.png")} alt="Scene Example 3" />

Another difference: a WebSpatial Scene **has no browser UI such as address bar, bookmarks, or history**. It's more like a PWA window on desktop platforms, but allow the whole Scene to have a fully transparent background, so no window borders is visible, only native UI left around the window area is the essential, minimal elements related to scene management, such as the drag bar and close button at the bottom of visionOS app windows, plus the WebSpatial app's own **Scene Menu**.

> Comparison: the left image shows the non-spatial version; the right image shows the spatial version with a fully transparent background.
>
> <div className="row">
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-12.png")} alt="Non-spatial version" />
>   </div>
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-13.png")} alt="Spatial version with transparent background" />
>   </div>
> </div>

## Scene Menu {#scene-menu}

A Window Scene in a WebSpatial app is equivalent to an independent window created by an [installed PWA](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa).

Because a WebSpatial Scene is [essentially a web page](#scenes-in-webspatial), it inherits the same general requirements and security/privacy considerations as any web page:

- Many webpages do not provide full in-app navigation and therefore rely on **native navigation buttons like "Back" and "Forward."**
- When a webpage errors, users often need to rely on the native "Refresh" button to reset it.
- If the content in the app window comes from a dynamically loaded webpage, users should be able to see the page's URL to check things like certificates and security/privacy info.
- Sometimes users want to copy the current URL for use in a browser or elsewhere.
- …

That's why PWA app windows include some native UI to provide the general features mentioned above.

<Image img={require("/assets/concepts/3-14.jpg")} alt="Scene Example 3" />

The PWA standard's [`display` property](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#display) in the [Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest) lets you control certain parts of this native UI - for example, **whether native navigation buttons appear**.

> The following image shows a desktop PWA in `minimal-ui` mode (native title bar with navigation buttons).
> <Image img={require("/assets/concepts/3-15.jpg")} alt="Scene Example 3" />
>
> The following images show an Android PWA in `minimal-ui` mode (native title bar, navigation buttons inside the menu).
>
> <div className="row">
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-16_2.jpg")} alt="Android PWA minimal-ui mode 1" />
>   </div>
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-17_2.jpg")} alt="Android PWA minimal-ui mode 2" />
>   </div>
> </div>
>
> In `standalone` mode on Android, the PWA has no title bar and no navigation buttons; only the multitasking view shows a native menu.
>
> <div className="row">
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-18_2.jpg")} alt="Android PWA standalone mode 1" />
>   </div>
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-19_2.jpg")} alt="Android PWA standalone mode 2" />
>   </div>
> </div>

WebSpatial is [**built on top of PWA**](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa), every WebSpatial Scene includes a native **Scene Menu**, just like a PWA window.

:::note
The Scene Menu shown in the image isn't the final design. It's a temporary test version. It's collapsed by default, and when expanded, it lets you view and copy the URL, use navigation buttons (depend on the `display` property in the Web App Manifest), etc.
:::

<Image img={require("/assets/concepts/3-20.jpg")} alt="Scene Example 3" />

## Scene Properties {#scene-props}

Window Scenes in WebSpatial apps have some Scene properties that are fully controlled by the developer.

The window plane can use a [**semi-transparent** material background](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds#for-window-scenes), rendered dynamically against the surrounding environment so it remains legible in any context. You can also round the four corners instead of keeping the default sharp angles.

<Image img={require("/assets/concepts/3-21.jpg")} alt="Scene Example 3" />

Alternatively, set the background to a [fully transparent material](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds#for-window-scenes) with no border, making the page content appear to float freely.

<Image img={require("/assets/concepts/3-22.jpg")} alt="Scene Example 3" />
<Image img={require("/assets/concepts/3-23.jpg")} alt="Scene Example 3" />

You can create native UI elements that hover on the window edge and provide global functionality (for example, a global navigation bar).

:::important
The current version of WebSpatial SDK does not support this feature natively. You can simulate it in a fully transparent window scene using regular HTML/CSS.
:::

<Image img={require("/assets/concepts/3-24.jpg")} alt="Scene Properties Example 1" />
<Image img={require("/assets/concepts/3-25.jpg")} alt="Scene Properties Example 2" />

## Spatial Layout {#spatial-layout}

In a 2D app, the **layout** determines the position and size of every UI element.
Layout is a set of **relationships**: elements affect each other. Changing one element's size or position can cascade changes to many others.

But as long as the UI content stays the same, the layout remains stable and essentially **static**.

In a spatial app, layout not only adds **depth** beyond height and width, it also introduces a new **dynamic relationship** - **spatial layout**:

Because users constantly move in the spatial environment (turning their heads, changing eye level by sitting or standing, bending, walking around), the UI must now consider **dynamic relationships between elements and the user**.

How UI elements adapt to those movements and interactions defines the spatial layout.

To simplify implementation, spatial layout is **scene-centric** by default. All content lives inside a scene and changes with that scene, and the scene itself adapts in response to changes in the user and the surrounding environment.

For example, as the distance between scene and user changes, a reading-oriented window scene may keep the same perceived size (smaller when close, larger when far), whereas a volume scene that mimics a real object will appear larger when nearer and smaller when farther.

<div className="row">
  <div className="col col--6">
    <video
      src="/assets/concepts/visionos-dynamic-window-scaling.mp4"
      autoPlay
      loop
      muted
      playsInline
      style={{ width: '100%', height: 'auto' }}
    />
  </div>
  <div className="col col--6">
    <video
      src="/assets/concepts/visionos-fixed-window-scaling.mp4"
      autoPlay
      loop
      muted
      playsInline
      style={{ width: '100%', height: 'auto' }}
    />
  </div>
</div>

## Scene Initialization {#scene-init}

Scenes are content containers uniformly managed by the OS in the [shared space](/docs/core-concepts/shared-space-and-spatial-apps). Centralized management is necessary because only the OS has the complete understanding of the user's environment, the dynamic relationships between scenes and the user ([Spatial Layout](#spatial-layout)), and what each app does and how they relate to one another.

Therefore, only the OS should make the **final decisions** about size, position, orientation, and other spatial-layout properties. Developers do not have **full control** over them, and even end-users are limited - they cannot arbitrarily resize a window or place it anywhere. These properties are **consistently constrained** by the
OS.

During scene creation, developers may supply **preferred initial values**, which the OS may accept or adjust.

Once created, these properties **cannot** be changed by app code, they're entirely controlled by the OS and the user's actions.

The classic example is the scene's [`defaultSize`](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes#init-scene).

> Example from the Quick Example:
>
> <div className="row">
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-28.png")} alt="Scene Initialization Example 1" />
>   </div>
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-29.png")} alt="Scene Initialization Example 2" />
>   </div>
> </div>

## Start Scene {#start-scene}

Every time a WebSpatial app launches, it **starts with a single Scene** called the **Start Scene**, from which the app can open additional Scenes.

Because the Start Scene is the entry point of the WebSpatial app, it is created and initialized entirely by native code ([WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk)). **The web code runs only after this Start Scene exists.**

Consequently, the Start Scene's type and initial configuration can only be set via the [Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest).

Additional scenes created later within the same WebSpatial app are [created by web code](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes#new-scene), where their initialization can also be configured in web code.

The URL loaded in the Start Scene is the very first page the WebSpatial app loads and runs. By default, it is defined by [`start_url`](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) in the Web App Manifest. If the WebSpatial app is launched through a specific URL, the Start Scene loads that URL instead.

> In the Quick Example, clicking buttons and links in the Start Scene opens two new Scenes:
> <Image img={require("/assets/concepts/3-30.png")} alt="Scene Example 3" />

---

// File: core-concepts/spatialized-elements-and-3d-container-elements

# Spatialized Elements and 3D Container Elements

[Spatial apps](/docs/core-concepts/shared-space-and-spatial-apps#spatial-apps) are composed of [Scenes](/docs/core-concepts/scenes-and-spatial-layouts), and the content in a Scene is made up of both 2D and 3D content.

For a [WebSpatial app](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-app), all content within the Scene is composed entirely of HTML elements.

## Spatialization of 2D Content Elements {#2d-elements}

2D content refers to existing HTML elements that can be [converted into "spatialized HTML elements"](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements) to gain spatial capabilities.

After a 2D HTML element is spatialized, its original capabilities remain unchanged by default, such as:

- Existing HTML attributes
- Existing CSS APIs ([exceptions](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds#stacking-order))
- Existing DOM APIs
- The ability to nest and compose with other HTML elements, whether spatialized or not
- Layout control for position and size on the X and Y axes
- ...

A spatialized 2D element mainly gains two new capabilities:

1. **Dynamic backgrounds**

   It can render its background based on the spatial environment around the app, for example, using translucent materials instead of a fixed solid color.

   :::info
   View [related WebSpatial APIs](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds).
   :::

   <Image img={require("/assets/concepts/4-1.jpg")} alt="Scene Example 4" />

2. **Spatial elevation**

   It can move, transform, and be laid out along the Z-axis in front of the web-page window, allowing it to be "elevated" into 3D space.

   :::info
   View [related WebSpatial APIs](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements).
   :::

   <Image img={require("/assets/concepts/4-2.jpg")} alt="Scene Example 4" />

Both new capabilities support nesting:

1. If the window or a parent element already has a material background, its child elements can still use [different translucent material](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds#translucent-options) backgrounds.

   <Image img={require("/assets/concepts/4-3.png")} alt="Scene Example 4" />
   <video
      src="/assets/concepts/visionos-glass-material-transition.mp4"
      autoPlay
      loop
      muted
      playsInline
      style={{ width: '100%', height: 'auto' }}
   />

2. If the parent element has been elevated and rotated in 3D space, child elements can continue to be elevated and rotated on that basis.

   <Image img={require("/assets/concepts/4-5.jpeg")} alt="Scene Example 4" />
   <Image img={require("/assets/concepts/4-6.jpg")} alt="Scene Example 4" />

## 3D Content Container Elements {#3d-elements}

3D content in a Scene comes from the new 3D content container elements introduced by the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api).

Currently, such elements are provided in the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) as React components. These serve as wrappers for the eventual standardized HTML elements, allowing web developers to start using potential future HTML/CSS APIs as directly as possible.

A 3D content container element is similar to a [Volumetric Scene](/docs/core-concepts/scenes-and-spatial-layouts#scenes-volume): it is a volumetric "bounding-box–like" local 3D space. However, it is **NOT managed by the OS**. It is still part of the current Scene, laid out with other 2D and 3D elements on the X, Y, and Z axes. Its position and size are determined by its own CSS styles and layout relationships.

A 3D content container element has the same capabilities as a 2D content element:

- General HTML attributes (`style`, `class`, `id`, and so on)
- General CSS APIs ([exceptions](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds#stacking-order))
- General DOM APIs
- The ability to nest and compose with other HTML elements (including spatialized and non-spatialized 2D elements, and other 3D elements).
- Layout control for position and size on the X and Y axes
- ...

It also inherits the spatial capabilities of spatialized HTML elements:

- As a whole, it can move, transform, and be laid out along the Z-axis in front of the web-page window so that it can be elevated into 3D space.

:::note
A 3D content container element is a transparent local 3D space. It has **no background** and therefore does not support material background properties.
:::

There are two kinds of 3D content container elements.

- **Static 3D content containers**

  Their 3D content comes from pre-authored [3D model files](/docs/development-guide/using-the-webspatial-api/add-3d-content).

  <Image img={require("/assets/concepts/4-7.jpg")} alt="Scene Example 4" />

- **Dynamic 3D content containers**

  Their 3D content is generated in real time by a [3D engine](/docs/development-guide/using-the-webspatial-api/add-3d-content).

  <Image img={require("/assets/concepts/4-8.png")} alt="Scene Example 4" />

## Interaction with 2D Content {#nature-interaction}

For those non-spatial elements **inside the 2D content**, interaction works the same way as 2D web content in a browser on a spatial-computing platform (for example, Safari on visionOS).

The default interaction mode on visionOS is called **Natural Interaction** and includes:

- **Indirect gestures**

  - **Eye gaze** for "selection (navigation)" and **pinch** for "activation (trigger)."
  - At the moment of the pinch gesture, the finger position corresponds to the gaze point, acting as the starting point. If the user keeps pinching, subsequent finger movement adjusts that point.

- **Direct gestures**

  - Moving a finger without touching an object is "selection (navigation)," while touching the object is "activation (trigger)."
  - As with touchscreens, after the finger touches an object it can move before releasing to fire move events.

<Image img={require("/assets/concepts/4-9.jpg")} alt="Scene Example 4" />

The browser engine on visionOS already lets 2D web content support Natural Interaction:

1. **Selection (navigation)**

   1. An interactive HTML element (it **must comply with the [Interaction Region](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#hover-effect) rules**) is targeted via eye gaze or by moving a finger close to it.
   2. **No JS events fire and no CSS state changes occur** during this phase, so the web page cannot show interaction cues. Essentially, the web page is unaware of the user's selection or actions at this point.
   3. During this phase, the OS provides **native interaction cues** to help users see what they are selecting.

2. **Activation (trigger)**
   1. At the moment of a pinch (indirect) or tap (direct), [JS events](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#js-events) fire on the selected element.
   2. If the user keeps pinching or pressing and then moves the finger, [JS events](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#js-events) continue to fire on the element.

:::info
See the detailed [interaction APIs](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#content-interaction) for more information.
:::

## Interaction with 3D Elements and Spatialized 2D Elements {#spatial-interaction}

If you want to interact with the specific 3D content inside a 3D container element, or with spatialized 2D elements that are "elevated" into space - as well as the 3D container element itself - you can't use the usual [low-level JS events](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#js-events). A new set of **high-level spatial gesture APIs** is provided on the React component.

> More docs to be added

---

// File: core-concepts/full-space-and-ar-capabilities

# Full Space and AR Capabilities

:::warning
Not supported in the current version of the WebSpatial SDK.
:::

---

// File: core-concepts/index

# Core Concepts

Learn the fundamental concepts of the WebSpatial SDK.

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk

# Step 1: Install the WebSpatial SDK

## Core runtime dependencies {#core-deps-for-runtime}

```bash npm2yarn
npm install @webspatial/react-sdk @webspatial/core-sdk @google/model-viewer three
```

:::info
`@google/model-viewer` and `three` are dependencies used inside the SDK, but their package sizes are relatively large compared to the SDK itself. Plus, many web projects might already use them, and having multiple versions installed could cause conflicts. In the future, the SDK might remove direct dependencies on them. So, they're declared as peerDependencies for now, you'll need to install them explicitly in your web project.
:::

### `@webspatial/react-sdk` {#react-sdk}

The [SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) offered by WebSpatial for React, which can be plugged into existing regular React projects to enable immediate use of the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api).

### `@webspatial/core-sdk` {#core-sdk}

Both the React SDK (and forthcoming SDKs for other Web frameworks) are implemented on top of the Core SDK. The Core SDK is a framework-agnostic, lower-level pure-JS API that relies internally on a non-standard JS Bridge API so that the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) can natively spatialize 2D HTML content and render 3D content.

## Core build-time dependencies {#core-deps-for-building}

```bash npm2yarn
npm install -D @webspatial/builder
```

### `@webspatial/builder` {#builder}

WebSpatial's packaging tool turns your website into a [Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk). It's the must-have dev tool right now for developing, testing, and distributing WebSpatial apps on visionOS.

See ["Step 2: Add the WebSpatial App Build Tool"](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps) for how to use it.

### Optional core build-time dependencies {#optional-deps-for-building}

These optional dependencies let each Web project include only the platform support it actually needs, keeping builds lean.

#### `@webspatial/platform-visionos` {#visionos}

```bash npm2yarn
npm install -D  @webspatial/platform-visionos
```

Includes the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) needed to generate a visionOS app and provide spatial capabilities.

:::note
This package is currently required, as visionOS is the sole spatial computing platform supported by WebSpatial at this stage.
:::

<a id="visionos-simulator"></a>

:::note[Install Xcode and the visionOS Simulator]

To build and package a visionOS app and debug it in the visionOS simulator, you need to install the relevant global dependencies: Xcode and the visionOS Simulator.

Prerequisite: a Mac computer

Steps:

1. Open the Mac App Store, search for "Xcode", and install it.
2. On first launch, agree to the license and enter the admin password to install additional components.
3. Click the top menu "Xcode" > "Settings…". In the "Components" tab, find visionOS and visionOS Simulator under "Platform Support", then install both.

:::

## Non-core build-time dependencies {#non-core-deps-for-building}

These plugins integrate with popular third-party toolchains to simplify setup and apply [essential performance optimizations and sensible defaults](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools).

### `@webspatial/vite-plugin` {#plugin-vite}

If you use a React + Vite project:

```bash npm2yarn
npm install -D @webspatial/vite-plugin
```

WebSpatial's Vite plugin adds the required optimizations and defaults when your Web project uses Vite as its web build tool and web server.

### `@webspatial/next-plugin` {#plugin-next}

If you use a React + Next.js project:

```bash npm2yarn
npm install -D @webspatial/next-plugin
```

WebSpatial's Next.js plugin adds the required optimizations and defaults when your Web project is based on Next.js framework.

### `@webspatial/rsbuild-plugin` {#plugin-rsbuild}

If you use a React + Rsbuild project:

```bash npm2yarn
npm install -D @webspatial/rsbuild-plugin
```

WebSpatial's Rsbuild plugin adds the required optimizations and defaults when your Web project uses Rsbuild as its web build tool and web server.

### `@webspatial/rspack-plugin` {#plugin-rspack}

If you use a React + Rspack project:

```bash npm2yarn
npm install -D @webspatial/rspack-plugin
```

WebSpatial's Rspack plugin adds the required optimizations and defaults when your Web project uses Rspack as its web build tool and web server.

---

// File: development-guide/enabling-webspatial-in-web-projects/index

# Enable WebSpatial in a Web Project

Previous step (2 choices):

- Option 1: [Use an existing Web project](/docs/development-guide/web-projects-that-support-webspatial/)
- Option 2: [Create a brand-new WebSpatial project](/docs/development-guide/web-projects-that-support-webspatial/creating-new-web-projects)

---

Next, bring the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) into your Web project and set up the WebSpatial development environment.

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest

# Add a Web App Manifest

## Create the Manifest file {#manifest-file}

First, create either `manifest.webmanifest` or `manifest.json` in your project.

:::tip
Both file types must be served as JSON by your web server. Any JSON MIME type is acceptable, such as `application/json`, the recommended type is `application/manifest+json`.
:::

Similar to static web files such as `robots.txt` and `favicon.ico` that are used without compilation or build process, the manifest file should be placed in a directory such as `public/`. Once the web server is running, these files should be directly accessible via URLs (e.g., `https://www.myapp.com/manifest.webmanifest`).

The manifest must contain at least the following properties:

```json5
{
  name: "My Awesome App",
  start_url: "/",
  display: "minimal-ui",
  icons: [
    {
      src: "/pwa-512x512.png",
      sizes: "512x512",
      type: "image/png",
      purpose: "any",
    },
    {
      src: "/pwa-1024x1024.png",
      sizes: "1024x1024",
      type: "image/png",
      purpose: "maskable",
    },
  ],
}
```

:::info

The [Add Icon Files](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-icon-files) section lists the exact icon requirements and provides ready-to-use sample icons.

If you only need to build an app that installs and runs in the visionOS simulator, you may omit the manifest entirely or exclude any of the properties above. For missing properties, [WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps) will fill in default placeholders automatically.

:::

## How manifest properties affect a WebSpatial app {#manifest-props}

### `start_url` {#start-url}

The entry point that loads when the app starts.

This property both sets the WebSpatial app's default [**Start Scene**](/docs/core-concepts/scenes-and-spatial-layouts#start-scene) and **determines how the app is packaged**:

- If [`start_url`](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Manifest/Reference/start_url) is an full URL (including an http-prefixed domain) or is completed into a full URL via the [`--base`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#base-for-devserver) option of the [WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps), the [Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) will **NOT** include website files (for example, the files Vite outputs to `dist/`). Instead, the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) will **load all pages and static files on demand from the web server** at runtime.
- If `start_url` is a relative path and you do NOT supply a domain through [`--base`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#base-for-devserver), the [Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) will bundle your entire website files (for example, everything in `dist/`). This produces a **fully offline** app that loads HTML and other static files directly from the package.

### `scope` {#scope}

(Optional) The [URL scope](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Manifest/Reference/scope) of the app. Defaults to all pages under the same path as `start_url`.

This property decides which URLs open inside the WebSpatial app (either navigating within the current [Scene](/docs/core-concepts/scenes-and-spatial-layouts) or opening a new one). URLs outside the scope open in the browser.

### `display` {#display}

Sets the [display](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Manifest/Reference/display) mode, which controls which native features appear in each Scene's **native [Scene Menu](/docs/core-concepts/scenes-and-spatial-layouts#scene-menu)**.

- **`minimal-ui`** - Adds native navigation buttons such as the "Back" button. Your pages don't need to implement full navigation (similar to a traditional website).
- **`standalone`** - Removes native navigation buttons such as the "Back" button. Only basic features like "View URL" remain. Your pages must handle all navigation (similar to a native app).
- **`fullscreen`** - Comparable to a game running full-screen on mobile (no battery/time indicators).
- **`tabbed`** - Tabs are not supported in WebSpatial. This mode automatically falls back to `minimal-ui`.
- **`browser`** - Not supported by PWAs or WebSpatial apps.

### `icons` {#icons}

Icons used during installation. [WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps) uses this setting to find icon files that meet spatial computing platform requirements.

At minimum, include:

- An icon with `"purpose": "any"` (required for all PWAs)
- A **maskable** icon at least **1024×1024** px with `"purpose": "maskable"` ([required by visionOS apps](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-icon-files))

:::info
Manifest properties not mentioned above are currently ignored by WebSpatial apps.
:::

## Link the Web App Manifest in HTML {#manifest-link}

Add a `<link rel="manifest" ...>` pointing to the manifest URL in the `<head>` of **every** HTML file.

:::info
Under the PWA spec, every page that belongs to this PWA site must reference the manifest via a `<link>` tag. Otherwise the page cannot be recognized as part of the PWA.

WebSpatial follows the same requirement - any page that should open inside the WebSpatial app (rather than in the browser) must include the manifest URL.
:::

```html
<link rel="manifest" href="/manifest.webmanifest" />
```

:::tip

If your web project hides the HTML template and you can't edit `<head>` directly, it should offer a way to inject custom `<link>` tags.

For example, in **rsbuild** you can modify the built-in HTML template through `rsbuild.config.js`:

```js
 plugins: [pluginReact()],
 html: {
   tags: [
     {
       tag: "link",
       attrs: { rel: "manifest", href: "/manifest.webmanifest" },
     },
   ],
 },
```

:::

## Automatically add the manifest with tooling {#manifest-tool}

If you prefer not to create the manifest file and modify HTML by hand, many tools can generate a Web App Manifest and inject it into every HTML file for you.

Example: In a Vite project, use the [VitePWA](https://vite-pwa-org.netlify.app/) plugin.

:::info
The following example shows the minimal configuration, disabling the Service Worker features that VitePWA enables by default and adding only the manifest.
:::

```js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { VitePWA } from "vite-plugin-pwa";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      manifest: {
        name: "My Awesome App",
        start_url: "/",
        scope: "/",
        display: "minimal-ui",
        icons: [
          {
            src: "pwa-192x192.png",
            sizes: "192x192",
            type: "image/png",
          },
          {
            src: "pwa-512x512.png",
            sizes: "512x512",
            type: "image/png",
          },
          {
            src: "pwa-1024x1024.png",
            sizes: "1024x1024",
            type: "image/png",
            purpose: "maskable",
          },
        ],
      },
      injectRegister: false,
      devOptions: {
        enabled: true,
      },
    }),
  ],
});
```

---

// File: development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-icon-files

# Add Icon Files

The best practice for a WebSpatial project is to include at least the following icon files:

| Icon Size       | Purpose                                                                                                         | Context                                                 | Transparent Background | Rounded Corners | How to Provide                                                                                                                                                                     |
| --------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- | ---------------------- | --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 48 × 48         | favicon.ico                                                                                                     | Browser tab bar                                         | Required               | Allowed         | [HTML `<link>`](https://github.com/joshbuchea/HEAD#icons)                                                                                                                          |
| 180 × 180       | [iOS app](https://developer.apple.com/design/human-interface-guidelines/app-icons#iOS-iPadOS-app-icon-sizes)    | "Add to Home Screen"                                    | Not allowed            | Not allowed     | [HTML `<link>`](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html) |
| 192 × 192       | Regular PWA                                                                                                     | Small icon on the home screen                           | Required               | Required        | Web App Manifest                                                                                                                                                                   |
| **512 × 512**   | Regular PWA                                                                                                     | Larger icon for splash screens, app stores, and similar | Required               | Required        | Web App Manifest                                                                                                                                                                   |
| **1024 × 1024** | [visionOS app](https://developer.apple.com/design/human-interface-guidelines/app-icons#visionOS-app-icon-sizes) | App icon in Vision Pro                                  | **Not allowed**        | **Not allowed** | WebSpatial + Web App Manifest                                                                                                                                                      |

:::tip
Ready-to-use sample icons (you can use this directly in your demo): [webspatial-icon-examples.zip](/assets/guide/webspatial-icon-examples.zip)
:::

In addition to the standard PWA requirements, a [**Packaged WebSpatial App**](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) has extra icon rules:

Because the minimum icon size for a visionOS app is 1024 × 1024 and the system automatically crops icons into a circle, your site must supply a PWA-standard icon with **a minimum size of 1024 × 1024** and of type **`maskable`** (no transparent background or rounded corners) before it can be published to the visionOS App Store.

:::tip
Other PWA icons (such as the 512 × 512 and 192 × 192 versions) are typically type `"any"` and may include rounded corners and transparency, because not every platform performs automatic cropping.
:::

At the very minimum, to run as a standalone app on desktop and visionOS, you need to provide two icon sizes:

- **512×512** (`"any"` type)
- **1024×1024** (`"maskable"` type)

In the [Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest), these two icons are configured like this:

```json5
  "icons": [
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-1024-maskable.png",
      "sizes": "1024x1024",
      "type": "image/png",
      "purpose": "maskable"
    }
  ]
```

---

// File: development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/index

# Prerequisite: Become a Minimal PWA

To give a WebSpatial app the capabilities and experience of a native [spatial app](/docs/core-concepts/shared-space-and-spatial-apps#spatial-apps) - like having its own [standalone window](/docs/core-concepts/scenes-and-spatial-layouts#scene-menu) instead of just running inside a browser - it needs to be more than just a bunch of webpages. **It has to become an actual "app" which means adding app-level info** like the app name, app icon, [which pages it includes](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#scope), and [what the start page is](/docs/core-concepts/scenes-and-spatial-layouts#start-scene).

> Traditional websites are a loose set of pages and do not include application-level metadata, containing only page-level info like the page title and favicon (page icon).

Some WebSpatial apps also need to be listed in app stores like native apps, reaching users on the platform the same way native apps do. That also requires adding app-level metadata.

:::warning
For today's [Hybrid-based](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) WebSpatial apps, listing in app stores is essential for user acquisition.
:::

While becoming an actual "app", the project must remain a **standard website** that can still run in regular browsers. This keeps [**key Web strengths**](https://developer.picoxr.com/document/web/introduce-power-of-web/): true cross-platform reach, shareable URLs, and on-demand usage without installation.

The **[PWA technology](https://web.dev/explore/progressive-web-apps)** defined in Web standards meets these requirements. It adds app-level info to a website and makes it installable. WebSpatial builds on many existing mainstream Web APIs, including the PWA standard.

Therefore, before introducing the WebSpatial API, make sure your site is already a valid PWA.

If your site is not yet a PWA, you only need to create the **simplest possible PWA** - as long as the site includes a valid [**Web App Manifest**](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest), it can be installed as a PWA and meet WebSpatial's requirements.

:::info
If you only need to create an app for [**installation and execution in the visionOS simulator**](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#run), you do not have to convert the site to a PWA first. [**WebSpatial Builder**](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps) will automatically supply placeholder values like the app name and icon.
However, to generate an installable app package, [**install it on a real Vision Pro device**](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#build), or [**distribute via App Store Connect**](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#publish) with a real name, icon, and other baseline app details, you must first turn the site into a PWA.
:::

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/test-pwa-installability

# Test PWA Installability

You can now launch the React site locally using your project's existing workflow.

Run the DevServer:

```bash npm2yarn
npm run dev
```

Or run a static web server:

<Tabs>
<TabItem value="vite" label="Vite">
```bash npm2yarn
npm run build
npm run preview
```
</TabItem>
<TabItem value="next" label="Next.js">
```bash npm2yarn
npm run build
npm run start
```
</TabItem>
</Tabs>

Then open the site's local URL in Chrome or Edge. You should see the PWA install button in the address bar of your browser:

<Image img={require("/assets/guide/pwa-1.jpg")} alt="Scene Example 1" />
<Image img={require("/assets/guide/pwa-2.jpg")} alt="Scene Example 2" />

Open your browser's DevTools, you should see how the browser has parsed the Web App Manifest for this page.

<Image img={require("/assets/guide/pwa-3.png")} alt="Scene Example 3" />

At this point, the site qualifies as a minimal PWA.

:::tip
After deploying to production, the site must be served over HTTPS. Otherwise, the browser will not recognize it as a PWA.
:::

---

// File: development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder

# Options for WebSpatial Builder

The command-line options for [WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps) fall into two categories, each recommended to be handled differently.

## Fixed options {#constant-options}

For every developer on the project, the following options should be configured identically and rarely change unless the project structure or configuration changes.

### `run` {#constant-options-for-run}

#### `--manifest`, `--manifest-url` {#manifest-for-run}

You can supply the local path to the [Web App Manifest file](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest) with `--manifest`, or provide the manifest's URL with `--manifest-url`.

- If neither option is set, the Builder reads the manifest from `public/manifest.webmanifest` or `public/manifest.json` by default.
- If no manifest is found at the default path, the `run` command silently falls back to an internal default manifest and default icons. The resulting build is suitable only for early simulator testing.
- If a manifest is provided but missing required fields, the `run` command silently fills the gaps with internal defaults. The resulting build is suitable only for early simulator testing.

:::tip

The default manifest information bundled with the Builder is as follows:

```json5
{
  name: "WebSpatialTest",
  display: "minimal-ui",
  start_url: "/",
  scope: "/",
}
```

:::

### `build` {#constant-options-for-build}

#### `--manifest`, `--manifest-url` {#manifest-for-build}

You can supply the local path to the [Web App Manifest file](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest) with `--manifest`, or provide the manifest's URL with `--manifest-url`.

- If neither option is set, the Builder reads the manifest from `public/manifest.webmanifest` or `public/manifest.json` by default.
- If no manifest is found at the default path, or the manifest is missing required fields, the Builder throws an error and aborts the build.

#### `--export` {#export}

The app package produced by the `build` command (for example, an IPA file) is written to the directory specified by `--export`.

- If omitted, the package is placed in the `build/` directory by default.

#### `--project` {#dist-for-build}

If you want to [bundle the site files for offline use](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) into the app package, use this option to tell the Builder where the built web files are located.

- If omitted, the Builder pulls web files from the `dist/` directory by default.

### `publish` {#constant-options-for-publish}

#### `--manifest`, `--manifest-url` {#manifest-for-publish}

You can supply the local path to the [Web App Manifest file](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest) with `--manifest`, or provide the manifest's URL with `--manifest-url`.

- If neither option is set, the Builder reads the manifest from `public/manifest.webmanifest` or `public/manifest.json` by default.
- If no manifest is found at the default path, or the manifest is missing required fields, the Builder throws an error and aborts the build.

#### `--project` {#dist-for-publish}

If you want to [bundle the site files for offline use](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) into the app package, use this option to tell the Builder where the built web files are located.

- If omitted, the Builder pulls web files from the `dist/` directory by default.

## Options best set via env vars {#inconsistent-options}

The following options either contain sensitive information (such as the password for an Apple developer account) or vary between developers (such as different Dev Server ports). They should therefore be supplied using environment variables rather than being committed to Git (see the [recommended npm scripts in the previous section](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#npm-scripts)).

:::tip
For best practice on environment variables, see ["(Optional) Simplify WebSpatial Builder with dotenv."](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/optional-simplify-webspatial-builder-using-dotenv)
:::

### `run` {#inconsistent-options-for-run}

#### `$XR_DEV_SERVER` (`--base`) {#base-for-devserver}

Use `--base` to specify the root part of URL for all HTML requests loaded in the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk). If the [`start_url` in the Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) is already set to a full URL, the root part of the URL is forcibly replaced by the value provided here.

:::note[Examples]

- `"start_url": "/home"`
- `--base="http://mydomain.com/app/"`

Resulting URL: `http://mydomain.com/app/home`

- `"start_url": "http://otherdomain.com/home"`
- `--base="http://mydomain.com/app/"`

Resulting URL: `http://mydomain.com/app/home`

- `"start_url": "/home"`
- `--base="/app/"`

Resulting URL: `/app/home`

:::

:::tip[Best practice]

Set `$XR_DEV_SERVER` to point at a [Dev Server dedicated to the WebSpatial app](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website), such as `http://localhost:3000/webspatial/avp/`.

In this setup, site files (for example, the `dist` directory) are NOT [bundled for offline use](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) into the Packaged WebSpatial App. After code changes you can rely on hot reload or simply refresh the page via the Dev Server, so there is no need to rerun `webspatial-builder run`, which greatly speeds up iteration.

:::

### `build` {#inconsistent-options-for-build}

#### `$XR_PRE_SERVER` (`--base`) {#base-for-preview}

Use `--base` to specify the root part of URL for all HTML requests loaded in the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk). If the [`start_url` in the Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) is already set to a full URL, the root part of the URL is forcibly replaced by the value provided here.

:::note[Examples]

- `"start_url": "/home"`
- `--base="http://mydomain.com/app/"`

Resulting URL: `http://mydomain.com/app/home`

- `"start_url": "http://otherdomain.com/home"`
- `--base="http://mydomain.com/app/"`

Resulting URL: `http://mydomain.com/app/home`

- `"start_url": "/home"`
- `--base="/app/"`

Resulting URL: `/app/home`

:::

:::tip

If `$XR_PRE_SERVER` points at [a Web Server dedicated to the WebSpatial app](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website), site files (for example, the `dist` directory) are NOT bundled for offline use into the Packaged WebSpatial App, so the web server must be reachable from the target device.

If you don't include a domain in either `$XR_PRE_SERVER` or `start_url`, the site files are [bundled for offline use](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url), so the app runs without fetching site files from a web server.

:::

### `build` or `publish` {#inconsistent-options-for-build-or-publish}

#### `$XR_BUNDLE_ID` (`--bundle-id`) {#bundle-id}

:::warning
Required during both real device testing (`build:avp`) and app distribution (`publish:avp`).
:::

Provide the App ID (Bundle ID) needed by App Store Connect via `--bundle-id`. You must [register a dedicated Bundle ID](https://developer.apple.com/help/account/identifiers/register-an-app-id/) in App Store Connect first.

#### `$XR_TEAM_ID` (`--teamId`) {#team-id}

:::warning
Required during both real device testing (`build:avp`) and app distribution (`publish:avp`).
:::

Provide your Apple Developer Team ID via `--teamId`.

### `publish` {#inconsistent-options-for-publish}

#### `$XR_PROD_SERVER` (`--base`) {#base-for-prod}

Use `--base` to specify the root part of URL for all HTML requests loaded in the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk). If the [`start_url` in the Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) is already set to a full URL, the root part of the URL is forcibly replaced by the value provided here.

:::note[Examples]

- `"start_url": "/home"`
- `--base="http://mydomain.com/app/"`

Resulting URL: `http://mydomain.com/app/home`

- `"start_url": "http://otherdomain.com/home"`
- `--base="http://mydomain.com/app/"`

Resulting URL: `http://mydomain.com/app/home`

- `"start_url": "/home"`
- `--base="/app/"`

Resulting URL: `/app/home`

:::

If `start_url` is an full URL with a production domain, and the web server [automatically serves WebSpatial-specific content when it detects the User Agent from the WebSpatial App Shell](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#single-web-server), you do NOT need to set this variable during the production release (`publish:avp`), the production URL comes directly from `start_url`.

If `start_url` is a relative URL, or the WebSpatial-specific content lives under a different URL, you must use this variable during the production release (`publish:avp` to supply the production domain and other root parts of the production URL.

:::tip

If `$XR_PROD_SERVER` points at [a Web Server dedicated to the WebSpatial app](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website), site files (for example, the `dist` directory) are NOT bundled for offline use into the Packaged WebSpatial App, so the web server must be reachable from the target device.

If you don't include a domain in either `$XR_PROD_SERVER` or `start_url`, the site files are [bundled for offline use](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url), so the app runs without fetching site files from a web server.

:::

#### `$XR_VERSION` (`--version`) {#version}

:::warning
Required during app distribution (`publish:avp`).
:::

Provide the version number required by App Store Connect via `--version`, for example "x.x". It must be higher than the previously submitted version.

#### `$XR_DEV_NAME` (`--u`) {#username}

:::warning
Required during app distribution (`publish:avp`).
:::

Provide the Apple Developer account email via `--u`.

#### `$XR_DEV_PASSWORD` (`--p`) {#password}

:::warning
Required during app distribution (`publish:avp`).
:::

Provide the [app-specific password](https://support.apple.com/102654) for the Apple Developer account via `--p`.

---

// File: development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/optional-simplify-webspatial-builder-using-dotenv

# (Optional) Simplify Builder Usage with dotenv

To avoid typing the same environment variables each time you run these [npm scripts](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#npm-scripts), you can place all required variables in a dotenv configuration file and have them loaded automatically before the scripts run.

## dotenv Files

First, create `.env.example` in the project root and commit it to Git:

```ini
XR_DEV_SERVER=
XR_PRE_SERVER=
XR_PROD_SERVER=
XR_BUNDLE_ID=
XR_TEAM_ID=
XR_VERSION=
XR_DEV_NAME=
XR_DEV_PASSWORD=
```

All developers must then create their own `.env.local` file after cloning the repository:

```shell
cp .env.example .env.local
```

:::tip
`*.local` is usually listed in `.gitignore`, so `.env.local` will not be committed to Git.
:::

## Used in npm scripts

Install dependencies:

```bash npm2yarn
npm install -D dotenv dotenv-cli
```

:::info
For Vite projects you do not need to install the `dotenv` package above, because Vite already supports dotenv. You still need `dotenv-cli` so that the variables in dotenv files take effect inside npm scripts.
:::

`dotenv-cli` lets npm scripts access the variables defined in dotenv files.

Wrap each of the WebSpatial Builder scripts in npm scripts with `dotenv -e .env.local -- sh -c 'original script'`, for example:

```json5
"run:avp": "dotenv -e .env.local -- sh -c 'webspatial-builder run --base=$XR_DEV_SERVER'",
"build:avp": "dotenv -e .env.local -- sh -c 'webspatial-builder build --base=$XR_PRE_SERVER --bundle-id=$XR_BUNDLE_ID --teamId=$XR_TEAM_ID'",
"publish:avp": "dotenv -e .env.local -- sh -c 'webspatial-builder publish  --base=$XR_PROD_SERVER --bundle-id=$XR_BUNDLE_ID --teamId=$XR_TEAM_ID --version=$XR_VERSION --u=$XR_DEV_NAME --p=$XR_DEV_PASSWORD'",
```

## Used in Node.js Scripts

If you need to use environment variables from dotenv files in other Node.js-based scripts, add the following line at the top of the script:

```js
import dotenv from "dotenv";

dotenv.config();

console.log(process.env.XR_ENV);
```

:::info

In Vite projects you can use Vite's built-in utilities to load variables from dotenv files in Node.js scripts.

For example, in `vite.config.js`:

```jsx
// diff-remove
import { defineConfig } from 'vite'
// diff-add
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig(({ mode }) => {
// diff-add
  const env = loadEnv(mode, process.cwd(), '')
// diff-add
  console.log(env.XR_ENV)
  return {
   plugins: [
     react(),
```

In other Node.js scripts:

```js
import { loadEnv } from "vite";

const env = loadEnv("", process.cwd(), "");

console.log(env.XR_ENV);
```

:::

## Used in Client-side JS Code

See ["Check if Running in WebSpatial Mode"](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode).

---

// File: development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/index

# Step 2: Add Build Tool for Packaged WebSpatial Apps

## WebSpatial Builder {#webspatial-builder}

To enable the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) features that current browser engines do not yet support and unlock spatial capabilities, your site must run inside the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk).

One way to obtain the WebSpatial App Shell is to package your existing Web project into a [Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) that can be installed and run independently on spatial-computing platforms such as visionOS.

:::tip

Another option is to pre-install the WebSpatial Browser app (in development) on the target platform and open the WebSpatial App's URL directly in that browser.

Because you cannot assume that visionOS users have installed - or are willing to install - this browser, packaging your site and distributing it through the app store remains the only way to guarantee that your WebSpatial App is available to visionOS users.

:::

During the development phase, you need to build an app, install it in the visionOS simulator or on your own device, and run it.

During the testing or distribution phase, you need to build an app, submit it to a platform such as App Store Connect for testing on other devices, or eventually publish it in an app store.

[`@webspatial/builder`](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#builder) covers all of these needs.

WebSpatial Builder is a command-line tool. The main command is `webspatial-builder`, which provides three subcommands:

### `run` {#run}

```shell
webspatial-builder run --base=$XR_DEV_SERVER
```

It builds a visionOS app from the current WebSpatial project, automatically launches the local visionOS simulator, installs the app, and runs it.

This command is totally for the development phase - the main one you'll use during the development process. It is the fastest way to preview and debug a [Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk). It is usually combined with a Dev Server: the app built with the `run` command needs to load [a special website URL generated by the Dev Server, specifically for the WebSpatial App Shell on visionOS](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website).

:::info

Apps generated by WebSpatial Builder use the [`start_url` field of the Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) to figure out where the HTML for its [Start Scene](/docs/core-concepts/scenes-and-spatial-layouts#start-scene) should come from.

:::

:::tip
The `run` command allows you to omit the Web App Manifest temporarily. Builder supplies default app information - including `start_url` - when the manifest file is absent.
:::

:::info

In a [standard PWA project](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa), the `start_url` in the Web App Manifest can be set in two ways: one includes the full URL with the production domain, and the other uses a relative path without the domain.

The second option is the best practice, because when running the site locally with a dev server, it'll automatically load the manifest from the local domain, not the production one.

:::

If your `start_url` is a full URL with a domain included, The `run` command supports a [`--base`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#base-for-devserver) option that allows you to set a root path that includes your local dev server's domain, which will replace the root part of the `start_url`.<br/>
If the [WebSpatial-specific site generated by the dev server](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website) uses a different URL root, you can include that in the `--base` too.<br/>
This way, you don't need to change your manifest or maintain multiple versions just to use the `run` command.

If your `start_url` is a relative path without a domain, you can still use the `--base` option to add the domain (which replaces the starting `/` in `start_url`).<br/>
But if you don't provide the `--base`, or if it doesn't include a domain too (like when it only includes [the specialized root path used by the WebSpatial-specific dev server](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website)), the `run` command will bundle all site files within this relative path into the app package, the app will load all the web files directly from your app package.<br/>
That makes development a lot more annoying - you won't get hot reloading, and you'll have to repackage and reinstall the app every time you make a change.

Therefore, when you use `run`, you almost always need the [`--base`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#base-for-devserver) to specify the root part of the WebSpatial-specific Dev Server URL (for example, `http://localhost:3000/webspatial/avp/`).

All [other `run`'s options](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder) are optional.

### `build` {#build}

```shell
webspatial-builder build --base=$XR_PRE_SERVER --bundle-id=$XR_BUNDLE_ID --teamId=$XR_TEAM_ID
```

Based on your current WebSpatial project, this builds a visionOS app package (an .ipa file) that's signed with your Apple Developer account, so you can test it on your real device (like a Vision Pro).

If your Apple Developer account is an enterprise account, the package can run on other people's devices.

Otherwise, it runs only on devices that sign in with the same account as the developer. In that case, testing on other devices requires the [`publish` command](#publish).

:::info

Apps generated by WebSpatial Builder use the [`start_url` field of the Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) to figure out where the HTML for its [Start Scene](/docs/core-concepts/scenes-and-spatial-layouts#start-scene) should come from.

:::

:::info

In a [standard PWA project](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa), the `start_url` in the Web App Manifest can be set in two ways: one includes the full URL with the production domain, and the other uses a relative path without the domain.

The second option is the best practice, because when running the site locally with a dev server, it'll automatically load the manifest from the local domain, not the production one.

:::

For these on-device tests, the URLs the WebSpatial app loads usually differ from the production URLs. If you want to use a testing URL, you must also include the [`--base` option](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#base-for-devserver) when you run `build` to supply the full root part (with a domain) of the testing URL.

When you configure [`start_url`](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) as a relative path, similar to [the usage with the `run` command](#run), if you either don't use the `--base` or only use it to replace the root path without adding a domain, the `build` command will package all the website files into the app package for offline use. The app will load everything locally at runtime.

:::tip

When using the `run` command, this offline packaging mode [isn't recommended](#run). But the situation differs for the `build` command: since it's mainly for internal testing before official release, you might not have a convenient way to deploy the current code as a publicly accessible web URL. Offline packaging avoids that network complications - once installed, the app can run right away.

:::

Additionally, when you use `build`, you must always provide [`--bundle-id`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#bundle-id) and [`--teamId`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#team-id) so the visionOS app can be signed.

All [other `build`'s options](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder) are optional.

### `publish` {#publish}

```shell
webspatial-builder publish  --base=$XR_PROD_SERVER --bundle-id=$XR_BUNDLE_ID --teamId=$XR_TEAM_ID --version=$XR_VERSION --u=$XR_DEV_NAME --p=$XR_DEV_PASSWORD
```

Builds a visionOS app from the current WebSpatial project, applies an Apple Developer signature, adds the other metadata required by App Store Connect, and automatically submits the build to App Store Connect for later testing, review, and store release.

:::info

Apps generated by WebSpatial Builder use the [`start_url` field of the Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) to figure out where the HTML for its [Start Scene](/docs/core-concepts/scenes-and-spatial-layouts#start-scene) should come from.

:::

:::info

In a [standard PWA project](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa), the `start_url` in the Web App Manifest can be set in two ways: one includes the full URL with the production domain, and the other uses a relative path without the domain.

The second option is the best practice, because when running the site locally with a dev server, it'll automatically load the manifest from the local domain, not the production one.

:::

When you configure [`start_url`](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) as a relative path, you must always include the [`--base` option](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#base-for-devserver) when you run `publish` to supply the full root part (with a domain) of the production URL.

Additionally, when you use `publish`, you must always provide [`--bundle-id`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#bundle-id) , [`--teamId`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#team-id) , [`--version`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#version) , [`--u`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#username) , and [`--p`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder#password) for signing and App Store Connect submission.

All [other `publish`'s options](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/options-of-the-webspatial-builder) are optional.

## npm scripts {#npm-scripts}

You could type the WebSpatial Builder command and all of the options above every time you run it, but that is inefficient. A best practice is to add npm scripts to `package.json` so the options become environment variables and you can run WebSpatial Builder through fixed familiar npm commands.

```json5
"run:avp": "webspatial-builder run --base=$XR_DEV_SERVER",
"build:avp": "webspatial-builder build --base=$XR_PRE_SERVER --bundle-id=$XR_BUNDLE_ID --teamId=$XR_TEAM_ID",
"publish:avp": "webspatial-builder publish  --base=$XR_PROD_SERVER --bundle-id=$XR_BUNDLE_ID --teamId=$XR_TEAM_ID --version=$XR_VERSION --u=$XR_DEV_NAME --p=$XR_DEV_PASSWORD",
```

Once the command-line options are converted to environment variables, you can [store most of them in a dotenv file](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps/optional-simplify-webspatial-builder-using-dotenv), so you do not have to set them manually each time.

---

// File: development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/configure-js-ts-compiler

# Configure the JS/TS Compiler

To use the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) inside a UI framework such as React, you need to integrate WebSpatial's framework SDK (currently only the [React SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#react-sdk)) into the JS/TS compiler used by your Web project. This allows the SDK to affect JSX transforms and other stages that involve the HTML/CSS APIs.

:::info
In builds targeting desktop/mobile platforms and regular browsers, [the SDK is inactive](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website) - it adds no extra code and makes no changes to behavior or performance.
:::

## TypeScript

In a React + TypeScript project, you typically integrate WebSpatial's React SDK in `tsconfig.json`.

```json5 title="tsconfig.json"
{
  "compilerOptions": {
    // diff-add
    "jsxImportSource": "@webspatial/react-sdk",
```

:::tip
If `tsconfig.json` is split into a client-side `tsconfig.app.json` and a Node.js-side `tsconfig.node.json`, add this configuration to both files.
:::

Some toolchains add an abstraction layer on top of `tsconfig`, so in these cases, you must use the toolchain's own configuration to modify `tsconfig`.

For example, if your Vite project is using SWC, you'll need to add the `jsxImportSource` via the SWC plugin config.

```js title="vite.config.js"
import { defineConfig } from "vite";
// diff-add
import react from "@vitejs/plugin-react-swc";

export default defineConfig({
  plugins: [
    react({
      // diff-add
      jsxImportSource: "@webspatial/react-sdk",
    }),
  ],
});
```

Example [using Rsbuild](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools#rsbuild):

```ts title="rsbuild.config.ts"
import { defineConfig } from '@rsbuild/core'
import { pluginReact } from '@rsbuild/plugin-react'

export default defineConfig({
  plugins: [
    pluginReact({
      swcReactOptions: {
        runtime: 'automatic',
        // diff-add
        importSource: '@webspatial/react-sdk',
      },
    }),
```

Example [using Rspack](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools#rspack):

```js title="rspack.config.mjs"
  module: {
    rules: [
      {
        test: /\.(jsx?|tsx?)$/,
        use: [
          {
            loader: 'builtin:swc-loader',
            options: {
              jsc: {
                parser: {
                  syntax: 'typescript',
                  tsx: true,
                },
                transform: {
                  react: {
                    // diff-add
                    importSource: '@webspatial/react-sdk',
                    runtime: 'automatic',
                    development: isDev,
                    refresh: isDev,
                  },
                },
```

## JavaScript

In a React + JavaScript project, the JS compiler is usually embedded inside the Web build tool, so you need to integrate WebSpatial's React SDK through the build tool's configuration file.

Example [using Vite](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools#vite):

```js title="vite.config.js"
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [
    react({
      // diff-add
      jsxImportSource: "@webspatial/react-sdk",
    }),
  ],
});
```

---

// File: development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools

# Add Optimizations and Defaults to Web Build Tools

In addition to [Configure the JS/TS Compiler](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/configure-js-ts-compiler), a Web project that includes the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) needs several essential performance optimizations and default configuration values (convention over configuration). These optimizations and defaults need to be implemented through the project's web build tool and web server.

If your project uses tools like Next.js, Vite, or Rsbuild that bundle both the web build tool and web server - you just need to add the corresponding [WebSpatial plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#non-core-deps-for-building) in their config. These ready-to-use plugins save you from manual setup and reduce boilerplate code.

<!-- If your project relies directly on a lower-level web build tool such as Webpack, you can follow the guidelines in this document to integrate these optimizations and defaults by hand. -->

:::info
What exactly is optimized and preconfigured is explained in ["Generate a WebSpatial-Specific Website"](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website) and ["Check if Running in WebSpatial Mode"](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode).
:::

## React + Vite {#vite}

Add the [Vite plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#plugin-vite) in `vite.config.ts` or `vite.config.js`:

```js title="vite.config.js"
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
// diff-add
import webSpatial from "@webspatial/vite-plugin";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    // diff-add
    webSpatial(),
    react({
```

If it's a TypeScript project, add `/// <reference types="@webspatial/vite-plugin" />` to `vite-env.d.ts`.

## React + Next.js {#next}

Add the [Next.js plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#plugin-next) in `next.config.ts` or `next.config.js`:

```ts title="next.config.ts"
// diff-add
import withWebSpatial from '@webspatial/next-plugin';

const nextConfig: NextConfig =
// diff-add
  withWebSpatial()(
    {
      // other config
```

If it's a TypeScript project, create a `env.d.ts` file and add `/// <reference types="@webspatial/next-plugin" />`.

## React + Rsbuild {#rsbuild}

Add the [Rsbuild plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#plugin-rsbuild) in `rsbuild.config.ts` or `rsbuild.config.mjs`:

```ts title="rsbuild.config.ts"
import { defineConfig } from "@rsbuild/core";
import { pluginReact } from "@rsbuild/plugin-react";
// diff-add
import webSpatial from "@webspatial/rsbuild-plugin";

export default defineConfig({
  plugins: [
    pluginReact({
      swcReactOptions: {
        runtime: "automatic",
        // diff-add
        importSource: "@webspatial/react-sdk",
      },
    }),
    // diff-add
    webSpatial(),
  ],
});
```

If it's a TypeScript project, add `/// <reference types="@webspatial/rsbuild-plugin" />` to `env.d.ts`.

## React + Rspack {#rspack}

Add the [Rspack plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#plugin-rspack) in `rspack.config.ts` or `rspack.config.mjs`:

```js title="rspack.config.mjs"
import path, { dirname } from "node:path";
import { defineConfig } from "@rspack/cli";
import { rspack } from "@rspack/core";
import RefreshPlugin from "@rspack/plugin-react-refresh";
// diff-add
import WebSpatialPlugin from "@webspatial/rspack-plugin";
import { fileURLToPath } from "node:url";

const isDev = process.env.NODE_ENV === "development";

// Target browsers, see: https://github.com/browserslist/browserslist
const targets = ["chrome >= 87", "edge >= 88", "firefox >= 78", "safari >= 14"];
const __dirname = dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  context: __dirname,
  entry: {
    main: "./src/main.tsx",
  },
  resolve: {
    extensions: ["...", ".ts", ".tsx", ".jsx"],
  },
  module: {
    rules: [
      {
        test: /\.svg$/,
        type: "asset",
      },
      {
        test: /\.(jsx?|tsx?)$/,
        use: [
          {
            loader: "builtin:swc-loader",
            options: {
              jsc: {
                parser: {
                  syntax: "typescript",
                  tsx: true,
                },
                transform: {
                  react: {
                    // diff-add
                    importSource: "@webspatial/react-sdk",
                    runtime: "automatic",
                    development: isDev,
                    refresh: isDev,
                  },
                },
              },
              env: { targets },
            },
          },
        ],
      },
    ],
  },
  plugins: [
    new rspack.HtmlRspackPlugin({
      template: "./index.html",
    }),
    isDev ? new RefreshPlugin() : null,
    // diff-add
    new WebSpatialPlugin(),
  ].filter(Boolean),
  optimization: {
    minimizer: [
      new rspack.SwcJsMinimizerRspackPlugin(),
      new rspack.LightningCssMinimizerRspackPlugin({
        minimizerOptions: { targets },
      }),
    ],
  },
  experiments: {
    css: true,
  },
  devServer: {
    port: 3000,
  },
  output: {
    // publicPath: '/mybase',
  },
});
```

If it's a TypeScript project, add `/// <reference types="@webspatial/rspack-plugin" />` to `react-env.d.ts`.

## Configuration Without Plugins {#no-plugins}

:::warning
In testing. Documentation coming soon.
:::

---

// File: development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website

# Generate a WebSpatial-Specific Website

After integrating the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) into the project's [TS/JS compiler](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/configure-js-ts-compiler) and [Web build tool & Web server](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools), your web project can produce a dedicated build for the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk), without affecting the original desktop/mobile site.

This build is essentially a standalone website that loads only inside a native spatial app ([Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk)) containing the App Shell built with [WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps). Web code in this context can tightly cooperate with native parts of the app to deliver web-controlled spatial capabilities.

## During simulator debugging {#for-simulator}

> All examples below are [based on Vite](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools)

### Run the regular Dev Server {#regular-dev-server}

Run the project's `dev` script as usual. The served site targets desktop/mobile platforms and regular browsers (including the default browser on XR platforms, such as Safari on visionOS).

```bash npm2yarn
npm run dev
```

- The HTML/CSS/JS output does NOT include WebSpatial SDK; all [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) calls are removed or ignored.
- Unsuitable for loading in the WebSpatial App Shell (no spatial effects).

### Run the dedicated Dev Server {#dedicated-dev-server}

To build specifically for the WebSpatial App Shell on visionOS, set the environment variable [`$XR_ENV`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode) from the WebSpatial SDK to `avp` when running `dev`.

```bash npm2yarn
XR_ENV=avp npm run dev
```

:::tip

Best practice: add an npm script for this dedicated Dev Server. Like:

```json5
"dev": "vite",
"dev:avp": "XR_ENV=avp vite",
```

:::

- The HTML/CSS/JS output does include WebSpatial SDK.
- To make sure the HTML/CSS works fine in regular browser engines that don't support the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) (like the default system WebView), all WebSpatial API calls in the HTML/CSS source are either removed or ignored and replaced with [non-standard JS Bridge API calls](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) in the JS output.
- Only suitable for loading in the WebSpatial App Shell; not suitable for regular browsers like Chrome on your computer, since it lacks the WebSpatial App Shell and the web UI won't display correctly.
- The served URL automatically adds the base segment `/webspatial/avp/` to keep things consistent with the distribution phase while still making development efficient during debugging.
  > Example: The regular Dev Server runs at `http://localhost:3000`; the dedicated Dev Server for visionOS runs at `http://localhost:3001/webspatial/avp/`.
- If the project defines a custom base, `/webspatial/avp/` is not prepended.
  > Example:
  >
  > ```js title="vite.config.js"
  > import { defineConfig } from "vite";
  > import vue from "@vitejs/plugin-react";
  > import WebSpatial from "@webspatial/vite-plugin";
  >
  > export default defineConfig({
  >   plugins: [react(), WebSpatial()],
  >   // diff-add
  >   base: "/my-project/",
  > });
  > ```
  >
  > URLs for the regular and dedicated Dev Servers become `http://localhost:3000/my-project/` and `http://localhost:3001/my-project/`.

### Use the dedicated Dev Server {#use-dedicated-dev-server}

Combine the dedicated Dev Server with [`webspatial-builder run`](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#run) (or the [`run:avp` script](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#npm-scripts)) to package and install a visionOS app in the simulator.

:::note

Pass the dedicated Dev Server URL as the [`--base` option (or `$XR_DEV_SERVER`) to replace the original `start_url` in the Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#run).

:::

```bash npm2yarn
npx webspatial-builder run --base=http://localhost:3001/webspatial/avp/
```

```bash npm2yarn
XR_DEV_SERVER=http://localhost:3001/webspatial/avp/ npm run run:avp
```

Once the app starts in the visionOS simulator, it'll automatically load the URL from the dedicated Dev Server.

Because `/webspatial/avp/` is injected as the base segment, every Web-build-tool-processed URL automatically includes `webspatial/avp/`, for example:

```html
<link rel="icon" href="/webspatial/avp/favicon.ico" sizes="any" />
<link
  rel="apple-touch-icon"
  href="/webspatial/avp/icons/apple-touch-icon.png" />
<script
  type="module"
  crossorigin
  src="/webspatial/avp/assets/index-CpANHSXr.js"></script>
<link
  rel="stylesheet"
  crossorigin
  href="/webspatial/avp/assets/index-B4Bp50KL.css" />
```

But when URLs appear within the JS logic, the web build tool won't automatically add that base part, you'll need to add it yourself.

In your JS code, you can use [`__XR_ENV_BASE__`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode) to get that base string.

```jsx
 <button
   onClick={() => {
     window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
   }}>
```

If you're using client-side routing like in the [Quick Example](/docs/quick-example#new-scene), you can set the base path centrally in the routing library so it's handled consistently.

Using `react-router-dom` as an example:

```jsx
  return (
    <Router basename={__XR_ENV_BASE__}>
      <Routes>
```

In this case, prefer `<Link />` over raw `<a>` tags or `window.open`, letting `react-router-dom` handle the base automatically:

```jsx
<Link to="/second-page" target="_blank">
  Open Second Page with a Link
</Link>
```

## During device testing and distribution {#for-real-device}

At this stage you must deploy the site to a web server accessible from real devices.

> Examples below use [Vite](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools).

### Multi-Web-Server mode {#multi-web-server}

The quickest and easiest way is to deploy two sites on different domains, just like [in the simulator debugging phase](#for-simulator).

One site serves the desktop/mobile version:

```bash npm2yarn
npm run build
npm run preview
```

- The HTML/CSS/JS output does NOT include WebSpatial SDK; all [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) calls are removed or ignored.
- Unsuitable for loading in the WebSpatial App Shell (no spatial effects).

The second site serves the visionOS-specific version.

When building and starting it, you need to set the [`$XR_ENV`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode) environment variable from the WebSpatial SDK to `avp`.

```bash npm2yarn
XR_ENV=avp npm run build
XR_ENV=avp npm run preview
```

The files in the `webspatial/avp/` path under the output folder (like `/dist`) are specifically for the WebSpatial App Shell on visionOS.

- The HTML/CSS/JS output does include WebSpatial SDK.
- To make sure the HTML/CSS works fine in regular browser engines that don't support the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) (like the default system WebView), all WebSpatial API calls in the HTML/CSS source are either removed or ignored and replaced with [non-standard JS Bridge API calls](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) in the JS output.
- Only suitable for loading in the WebSpatial App Shell; not suitable for regular browsers like Chrome on your computer, since it lacks the WebSpatial App Shell and the web UI won't display correctly.

Under default settings:

- The starting URL, along with all Web-build-tool-processed URL will automatically get `/webspatial/avp/` added to the base. For example:
  ```html
  <link rel="icon" href="/webspatial/avp/favicon.ico" sizes="any" />
  <link
    rel="apple-touch-icon"
    href="/webspatial/avp/icons/apple-touch-icon.png" />
  <script
    type="module"
    crossorigin
    src="/webspatial/avp/assets/index-CpANHSXr.js"></script>
  <link
    rel="stylesheet"
    crossorigin
    href="/webspatial/avp/assets/index-B4Bp50KL.css" />
  ```
- Just like when [using the dedicated Dev Server](#use-dedicated-dev-server), you need to manually add the base path to URLs in the JS logic. If you're using client-side routing, you can set this base path centrally through your routing library.

To use different domains to separate the two versions of the site and just use `/` as the base (skipping `webspatial/avp/`), configure as follows:

- Begin by configuring a custom base in the URL to differentiate the two site versions. With a custom base, WebSpatial SDK skips adding `/webspatial/avp/` automatically.
- Always output to the root directory of `dist/`.

```js title="vite.config.js"
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import WebSpatial from "@webspatial/vite-plugin";

// https://vite.dev/config/
export default defineConfig({
  // diff-add
    base: process.env.NODE_ENV === 'production'
  // diff-add
      && (
  // diff-add
        process.env.XR_ENV !== 'avp'
  // diff-add
          ? 'https://myproject.com/'
  // diff-add
         : 'https://webspatial.myproject.com/'
  // diff-add
      ) || ''
    build: {
      outDir: 'dist',
    },
    plugins: [
      WebSpatial({
  // diff-add
        outputDir: "",
      }),
      react(),
```

### Single-Web-Server mode {#single-web-server}

Another option is to use a single web server to serve both the desktop/mobile version and the version for the WebSpatial App Shell in visionOS. This avoids extra deployment steps, domains, and server resource usage.

In this case, you'll need to run the project's build script twice, one after the other.

1. First build: generates the usual HTML and static files for desktop, mobile, and regular browsers.
2. Second build: with [`XR_ENV=avp`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode), generates the HTML and static assets specifically tailored for the WebSpatial App Shell in visionOS.

:::info
During the second build, the WebSpatial plugin keeps the first build's files and appends new files.
:::

```bash npm2yarn
npm run build && XR_ENV=avp npm run build
```

:::tip

Best practice: chain both builds in one npm script.

```json5
"build": "vite build && XR_ENV=avp vite build",
```

:::

Output location is set by the web build tool's defaults and custom config. For example, Vite puts build output in the `dist/` by default, you can change that with `build.outDir`.

```js title="vite.config.js"
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  build: {
    // diff-add
    outDir: 'web-dist',
    emptyOutDir: true,
    assetsDir: 'static',
  },
  plugins: [
```

Example output:

```
web-dist
├── favicon.ico
├── icons
│   ├── icon-1024-maskable.png
│   └── icon-512.png
├── index.html
├── manifest.webmanifest
├── static
│   ├── index-B4Bp50KL.css
│   └── index-xAPzJf4I.js
└── webspatial
    └── avp
        ├── favicon.ico
        ├── icons
        │   ├── icon-1024-maskable.png
        │   └── icon-512.png
        ├── index.html
        ├── manifest.webmanifest
        └── static
            ├── index-B4Bp50KL.css
            └── index-Bk-ZYFXx.js
```

- Root level: desktop/mobile files.
- `webspatial/avp/`: visionOS WebSpatial files (different hashes because the SDK is included).
- Within `webspatial/avp/`, all web-build-tool-processed URLs prepend `webspatial/avp/`.

Two serving approaches:

1. Configure the server so all web page requests with `/webspatial/avp/` as the base will read HTML files from the `dist/webspatial/avp/` directory.
   > In this case, just like with the [dedicated Dev Server](#use-dedicated-dev-server) or the [multi-web-server](#multi-web-server) mode, you'll need to manually add the base part to your web links in JS logic. If you're using client-side routing, you can set the base path centrally in the routing library for consistency.
2. Detect the [special User-Agent string of the WebSpatial App Shell](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode#ua). Serve HTML files from `dist/webspatial/avp` for those web page requests; otherwise serve from `dist/`.
   > In this case you'll need to set a custom base URL in your web build tool's config, then the WebSpatial SDK won't automatically add `/webspatial/avp/`.
   >
   > ```js title="vite.config.js"
   > export default defineConfig({
   >   // diff-add
   >    base: 'https://myproject.com/'，
   > ```

### Usage 1: Use built-in Static Web server from your web build tool {#static-web-server}

E.g. with [Vite or Rsbuild/Rspack](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools):

```bash npm2yarn
npm run preview
```

Best aligned with the [multi-Web-Server](#multi-web-server) approach.
With custom routing (mapping `/webspatial/avp/` requests to HTML files in `dist/webspatial/avp/` directory), the [single-Web-Server](#single-web-server) approach also works.

### Usage 2: Use third-party static web hosting {#static-web-hosting}

E.g. with Vercel, Cloudflare Pages, or GitHub Pages.

Similar to [Usage 1](#static-web-server) and suits the [multi-Web-Server](#multi-web-server) approach.

For GitHub Pages, deploy the WebSpatial version separately:

```shell
npm install -D gh-pages
gh-pages -d dist/webspatial/avp
```

### Usage 3: Use dynamic Web server with SSR {#ssr-server}

E.g. with Next.js:

```bash npm2yarn
npm run start
```

Because in this case webpages share a single HTML template (or none), differentiating by template is impossible. The [multi-Web-Server](#multi-web-server) approach is recommended.

Deploy a dedicated SSR server for WebSpatial and set the root path for static web file URLs to point to the directory or CDN address where the WebSpatial-specific files are stored.

```js title="next.config.js"
module.exports = {
  assetPrefix: process.env.NODE_ENV === 'production'
    ? 'https://cdn.example.com/webspatial/avp'
    : '/static/webspatial/avp',
```

### Usage 4: Use self-hosted dynamic web server {#dynamic-web-server}

E.g. with a Node.js server based on NestJS framework

Use the second serving option of the [single-Web-Server](#single-web-server) approach: detect the [WebSpatial App Shell's User-Agent string](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode#ua) and serve HTML files from `dist/webspatial/avp` directory, otherwise from `dist/` directory.

---

// File: development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode

# Check If Running in WebSpatial Mode

The [previous section](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website) explained that WebSpatial SDK can automatically build two sets of site assets:

- One set targets desktop/mobile platforms and regular browsers and does not include the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk).
- The other set targets the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) and does include the WebSpatial SDK.

Your own application code may also contain logic that is specific to WebSpatial apps, such as:

- Spatial UI that differs greatly from a normal web UI
- 3D content unique to WebSpatial apps

> Example project: https://github.com/webspatial/sample-techshop
>
> <div className="row">
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-12.png")} alt="Non-spatial version" />
>   </div>
>   <div className="col col--6">
>     <Image img={require("/assets/concepts/3-13.png")} alt="Spatial version with transparent background" />
>   </div>
> </div>
> The left image shows the non-spatial UI; the right image shows the spatial UI.

This code shouldn't run or even be included in the build for the desktop/mobile platform and regular browsers.

To achieve this optimization, confidently leverage spatial features and innovate freely, you need a reliable way to know whether the code is running in a WebSpatial app or in a regular website.

## Recommended JS solution {#js-solution}

If your web project includes a Node.js-based server, you first need to decide whether you're using a [single-web-server mode](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#single-web-server) or [multi-web-server mode](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#multi-web-server).

In multi-web-server mode, the server for WebSpatial sets the [`$XR_ENV`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#dedicated-dev-server) environment variable when it starts, so your server code can just check that variable to know if it's running in the WebSpatial-specific server.

If you're using a single-web-server mode, you'll need to check the User-Agent string in web requests at runtime to identify whether the request is coming from a regular browser or the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk).

### WebSpatial-specific UA string {#ua}

For [Packaged WebSpatial Apps](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) on visionOS generated by [WebSpatial Builder](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps), the UA string is as follows:

```http {3}
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7; wv)
AppleWebKit/605.1.15 (KHTML, like Gecko)
WebSpatial/0.1.17
```

For third-party browsers that support WebSpatial apps on visionOS (with built-in WebSpatial App Shell, currently in development), the UA string is as follows:

```http {3}
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)
AppleWebKit/605.1.15 (KHTML, like Gecko)
WebSpatial/0.1.17 Safari/605.1.15
```

### For client-side JS {#client-js-solution}

In client-side JS, you can either check the [UA string](#ua) at runtime to see if the code is running in a WebSpatial app, or inject the [`$XR_ENV`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#dedicated-dev-server) environment variable during the build so it's available as a constant in your client-side code.

:::info
In Vite you can access it directly with `import.meta.env.XR_ENV`, no extra config needed.
:::

You can also inject other constants derived from **`$XR_ENV`**.

For example, if you use client-side routing, it is best to inject a **`__XR_ENV_BASE__`** constant:

```js title="vite.config.js" {3-7}
// https://vite.dev/config/
export default defineConfig({
  define: {
    __XR_ENV_BASE__: process.env.XR_ENV
      ? JSON.stringify(`/webspatial/${process.env.XR_ENV}`)
      : undefined,
  },
  plugins: [
```

:::info
The [WebSpatial's plugins for web build tools](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools) automatically inject **`__XR_ENV_BASE__`**, so you can skip the manual config above.
:::

See the usage example in the **[Quick Example](/docs/quick-example/)**.

```jsx
<Router basename={__XR_ENV_BASE__}>
```

```jsx
 <button
   onClick={() => {
     window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
   }}>
```

## Recommended CSS solution {#css-solution}

### A future standardizable approach

:::warning
This API is not yet supported by WebSpatial SDK.
:::

<details>
<summary>Use a media query in CSS to match the <code>space</code> color scheme:</summary>

On spatial-computing platforms the background environment color is unpredictable and changes with viewpoint and location, so the classic light/dark mode does not apply.

The WebSpatial API introduces a new color scheme called **`space`**, which is recognized only in WebSpatial apps. You can use it to target WebSpatial-specific CSS rules.

```css
@media (prefers-color-scheme: space) {
```

</details>

### A practical solution for now

Configure your web build tool so that **`$XR_ENV`** is injected into HTML.

E.g. with [Vite](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools):

1. Install the **vite-plugin-html** plugin.

```bash npm2yarn
npm install -D vite-plugin-html
```

2. Update `vite.config.js`.

```js
// diff-add
import { createHtmlPlugin } from "vite-plugin-html";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
// diff-add
    createHtmlPlugin({
// diff-add
      inject: {
// diff-add
        data: {
// diff-add
          XR_ENV: process.env.XR_ENV,
// diff-add
        },
// diff-add
      },
// diff-add
    }),
```

3. Modify the HTML template and add a class name that is only present when **`XR_ENV`** indicates spatial mode, for example on `<html>`.

<!-- prettier-ignore-start -->
```html
// diff-add
<%- XR_ENV === 'avp' ? `
// diff-add
<html lang="en" class="is-spatial">
  // diff-add
  ` : `
  <html lang="en">
    // diff-add
    ` %>
```
<!-- prettier-ignore-end -->

In your CSS, wrap any WebSpatial-specific rules under `html.is-spatial`.

```css {1}
html.is-spatial {
  .my-card {
```

---

// File: development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/index

# Step 3: Integrate the WebSpatial SDK into Web Build Tools

Integrate the SDK into your project's toolchain and web server to enable spatial capabilities, while still keeping it a standard, cross-platform website.

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: development-guide/index

# Overview

Comprehensive guide for developing with WebSpatial SDK.

:::tip
It is highly recommended to try the [Quick Example](/docs/quick-example) and get familiar with the [Core Concepts](/docs/core-concepts) before using this Development Guide.
:::

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: development-guide/using-the-webspatial-api/spatialize-html-elements

# Spatialize HTML Elements

:::info
Basic concept: [Spatialized Elements and 3D Container Elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements)
:::

:::note

Because the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) currently offers only a [React SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#react-sdk), all examples in this document use React.

APIs covered in this section:

- `enable-xr`, `__enableXr__`, `enableXr`
- `cursor: pointer`

:::

## Enable spatialization {#spatialize}

With the current WebSpatial SDK, an HTML element must be marked with a temporary flag before you can use any [spatial APIs](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api).

:::note
In a future W3C specification, we hope that HTML elements won't need to be explicitly marked as spatial to use spatial APIs - just using a spatial API should implicitly make them [spatialized HTML elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements). For now the flag is required for performance and other practical reasons.
:::

You can apply the flag in three ways:

1. Add the attribute `enable-xr` to the element.

```jsx
<div className="card" enable-xr>
```

2. Add `__enableXr__` to the element's class name.

```jsx
<div className="card __enableXr__">
```

3. Add `enableXr: true` in the element's inline style.

```jsx
<div className="card" style={{ enableXr: true, marginTop: '10px' }}>
```

Supporting all three options lets you work with a wide range of third-party component libraries.

Most component libraries let you customize things like attributes, className, or style on internal HTML elements for styling. As long as you have access to any of these, you can pass in the special marker to spatialize the element inside the component.

Example 1:

```jsx showLineNumbers {15,16,18}
// third-party component
const Button = ({ children, className, style, ...rest }) => {
  return (
    <button
      className={`default-button ${className || ""}`}
      style={{ backgroundColor: "blue", color: "white", ...style }}
      {...rest}>
      {children}
    </button>
  );
};

// usage
<Button
  className="custom-btn __enableXr__"
  style={{ fontSize: "14px", enableXr: true }}
  data-testid="submit-btn"
  enable-xr>
  Submit
</Button>;
```

Example 2:

```jsx showLineNumbers {18,19,20}
// third-party component
const Card = ({ children, headerClassName, headerStyle, headerProps }) => {
  return (
    <div className="card">
      <div
        className={`card-header ${headerClassName || ""}`}
        style={headerStyle}
        {...headerProps}>
        Card Title
      </div>
      <div className="card-body">{children}</div>
    </div>
  );
};

// usage
<Card
  headerClassName="custom-header  __enableXr__"
  headerStyle={{ backgroundColor: "gray", enableXr: true }}
  headerProps={{ "aria-label": "Card Title", "enable-xr": true }}>
  Card Content
</Card>;
```

After the flag is applied, the element keeps all of its original capabilities and also gains access to the [spatial APIs](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) provided by the WebSpatial SDK, including the [CSS APIs](#css) and [DOM APIs](#dom) described below.

## Cross-platform {#cross-platform}

A spatialized element has spatial capabilities only when running inside the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk).

On desktop/mobile platforms and regular browsers, [the build output does not include the WebSpatial SDK implementation](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website). Calls to the WebSpatial API are removed automatically, and the elements remain ordinary HTML elements in the React DOM.

So when you enable spatialization for an HTML element, you **do not need to write any if-else logic**, this API is designed to work cross-platform by default.

## CSS Capabilities {#css}

On a spatialized element, you can use WebSpatial APIs in all common CSS authoring styles, including:

1. Embedded Global CSS

```jsx
import React from 'react';

function App() {
  return (
    <div>
      <style>{`
        h1 {
        // diff-add
          --xr-background-material: translucent;
        }
      `}</style>
      <h1
              // diff-add
        enable-xr
      >Hello World</h1>
```

2. Linked Global CSS

```jsx
import React from 'react';
import './styles.css';

function App() {
  return (
    <div>
      <h1
              // diff-add
        enable-xr
      >Hello World</h1>
```

```css
h1 {
  // diff-add
  --xr-background-material: translucent;
}
```

3. Inline CSS

```jsx
import React from 'react';

function App() {
  return (
    <div>
      <h1
        style={{
                  // diff-add
          '--xr-background-material': 'translucent'
        }}
                // diff-add
        enable-xr
      >Hello World</h1>
```

4. CSS-in-JS solutions that dynamically change global styles, like styled-components.

```jsx
const StyledTitle = styled.h1`
        // diff-add
  --xr-background-material: translucent;
`
function App() {
  return (
    <div>
      <StyledTitle
              // diff-add
        enable-xr
      >Hello World</h1>
```

CSS Modules, PostCSS, and other pre-compiled CSS pipelines work as well.

## DOM Capabilities {#dom}

If you bypass React and manipulate the spatialized element directly through `querySelector` or similar DOM APIs, the [WebSpatial API will not work correctly](/docs/development-guide/web-projects-that-support-webspatial/).

Instead, obtain the DOM node of the spatialized element via React's Ref API, for example:

```jsx
import React from 'react';

function App() {
  const ref = useRef(null)
  return (
    <div>
      <h1
              // diff-add
        ref={ref}
        className="title"
        style={{
          position: 'relative',
          '--xr-back': '100'
        }}
                // diff-add
        enable-xr
      >Hello World</h1>
```

You can then read or write [`--xr-back`](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements) through `ref.current.style`, or remove it with `ref.current.style.removeProperty`.

You can also modify `ref.current.className` as needed.

## Animation Capabilities {#animation}

The WebSpatial SDK does not yet support using spatial APIs inside pure CSS animations.

You can create animations with JS animations. For example, using the Ref API and DOM API [mentioned earlier](#dom) to update WebSpatial styles frame by frame.

The following JS animation libraries have been tested:

- Popmotion
- React Spring
- GSAP
- Tween.js
- Anime.js

## Internal Content Interaction {#content-interaction}

Whether or not an element itself is spatialized, its child-element interactions on spatial-computing platforms such as visionOS are based on [natural interaction](/docs/core-concepts/spatialized-elements-and-3d-container-elements#nature-interaction).

Most of the natural interactions work like touch interactions. One key difference is that during [indirect interaction (eye-hand interaction)](/docs/core-concepts/spatialized-elements-and-3d-container-elements#nature-interaction) an element must qualify as an **Interaction Region** to receive the system-provided **Hover Effect**.

### Hover Effect {#hover-effect}

During the [Select (Navigation)](/docs/core-concepts/spatialized-elements-and-3d-container-elements#nature-interaction) phase - indirect or direct - no JS events fire and no CSS state changes (such as `:hover`) occur, just like on a touch screen.

So web code can't show any interaction cues at all. Basically, the page has no idea what the user is trying to do at that moment.

> For privacy reasons only the operating system knows which element the user's gaze is on or which element the finger is approaching, the web page itself does not.

Instead the operating system (including the browser engine) shows **native visual feedback**:

- In direct interaction, the motion of the user's finger itself serves as feedback.
- In indirect interaction, the system renders a **Hover Effect** (for example, a glowing outline floating in front of the element under gaze). This is not the CSS `:hover` state; it is a native effect.

Only elements recognized as **Interaction Regions** can be targeted and will display the Hover Effect.

An element becomes an Interaction Region if any of the following is true:

- It is a native HTML button, link, or menu element, or any element with an equivalent ARIA role.
- It is an input or form element.
- Otherwise add the CSS property `cursor: pointer` to mark any element as an Interaction Region.

<Image img={require("/assets/guide/hand-1.jpg")} alt="Scene Example 1" />

### JavaScript events {#js-events}

After the [Confirm (Activate)](/docs/core-concepts/spatialized-elements-and-3d-container-elements#nature-interaction) phase, indirect and direct interactions fire the same JavaScript events as touch screens:

<p className="row">
  <div className="col col--6">
    <Image img={require("/assets/guide/hand-2.jpg")} alt="" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/guide/hand-3.jpg")} alt="" />
  </div>
</p>

For indirect interaction the sequence is:

1. At the moment of the pinch gesture, the system dispatches `pointerover`, `pointerenter`, and `pointerdown`.
2. A `touchstart` event is dispatched (touch emulation).
3. If the fingers stay pinched, moving the hand dispatches:
   1. `pointermove`
   2. `touchmove` (touch emulation)
4. When the fingers release, the system dispatches `pointerout`, `pointerleave`, and `pointerup`.
5. A `touchend` event follows (touch emulation).
6. For desktop compatibility a series of mouse events is then emulated: `mouseover`, `mouseenter`, `mousemove`, `mousedown`, `mouseup`, and the CSS `:hover` state (cleared when interacting elsewhere).
7. Finally a `click` event signifies the confirmed action.

You can build higher-level gestures such as drag-and-drop on top of these low-level events.

Example:

<div style={{ width: '100%', maxWidth: '860px', textAlign: 'center', position: 'relative' }}>
  <a href="https://youtu.be/d8RcEiV-WM4?si=MyfgPKQ4qGZN80lw" target="_blank">
    <img src="/assets/guide/hand-4.jpg" style={{ width: '100%' }} />
    <div style={{
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      background: 'rgba(0, 0, 0, 0.7)',
      color: 'white',
      padding: '10px 20px',
      borderRadius: '5px',
      fontSize: '16px',
      cursor: 'pointer'
    }}>Watch Video</div>
  </a>
</div>

## Self interaction {#self-interaction}

> To be added

---

// File: development-guide/using-the-webspatial-api/add-material-backgrounds

# Add Material Backgrounds

:::info

Basic concepts:

- [Scenes and Spatial Layouts](/docs/core-concepts/scenes-and-spatial-layouts)
- [Spatialized Elements and 3D Container Elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements)

:::

:::note

Because the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) currently offers only a [React SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#react-sdk), all examples in this document use React.

APIs covered in this section:

- `--xr-background-material`
- `border-radius`, `display`, `visibility`, `opacity`
- `--xr-z-index`

:::

With the help of the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk), two main subjects in each [Scene](/docs/core-concepts/scenes-and-spatial-layouts) of the WebSpatial app can dynamically render their background based on the surrounding spatial environment.

## Translucent or Fully Transparent Window Scenes {#for-window-scenes}

The first subject is the entire [Window Scene](/docs/core-concepts/scenes-and-spatial-layouts#scenes-window) and the webpage itself.

You can give the `<html>` tag a style that makes the whole window use a translucent material background with rounded corners, or turn the window fully transparent and border-less.

Example based on the [Quick Example](/docs/quick-example/): a Window Scene with a translucent material background and rounded corners

```css {3}
html.is-spatial {
  background-color: transparent;
  --xr-background-material: translucent;
  border-radius: 10%;
```

<Image img={require("/assets/guide/2-1.jpg")} alt="Scene Example 2" />

- To add a translucent background, the default value is `translucent`. If the window is nested inside other translucent material content and needs to be visually separated, you can choose from [other material options](#translucent-options).
- Use `border-radius` to control the roundness of the window border.
- The same style can be written inline, for example `<html style="--xr-background-material: translucent;">`.
- You can also set it dynamically through `document.documentElement.style`.
- The default value of `--xr-background-material` is `none`. If you omit this property in the window style or set it explicitly to `none`, the window falls back to the default opaque webpage background color like in a regular browser.
  > Note that `none` means "do not apply any custom setting". It is not equivalent to "no material background".

Example from the [Techshop demo](/docs/introduction/built-on-the-existing-web-ecosystem#example-techshop): a fully transparent, border-less window scene

```css {3}
html.is-spatial {
  background-color: transparent;
  --xr-background-material: transparent;
```

<Image img={require("/assets/guide/2-2.jpg")} alt="Scene Example 2" />

## Translucent HTML Elements {#for-html-elements}

The second subject is any [spatialized HTML element](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements).

Unlike a web page window, HTML elements are naturally transparent (you can see the parent node's background through them). After an element is spatialized, **its default state is already a fully transparent material background**, equivalent to `--xr-background-material: transparent`.

> For a spatialized HTML element, `--xr-background-material: none` (no custom setting) is the same as `--xr-background-material: transparent`.

However, you can only perceive this fully transparent material once the spatialized HTML element has been [elevated](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements) into 3D space.

Example based on the [Quick Example](/docs/quick-example/):

```css
  .link-card {
    // diff-remove
    --xr-background-material: translucent;
    border-radius: 20px;
    position: relative;
    --xr-back: 50;
    top: 20px;
```

Removing the `--xr-background-material` property from the `.link-card` element reveals that it is transparent by default.

<Image img={require("/assets/guide/2-3.jpg")} alt="Scene Example 2" />

Whether or not the spatialized HTML element is elevated, you can set `--xr-background-material: translucent` (or one of the [other options](#translucent-options)) to give it a translucent background.

Example based on the [Quick Example](/docs/quick-example/):

```css
  .link-card {
    //diff-add
    --xr-background-material: translucent;
```

<Image img={require("/assets/guide/2-4.jpg")} alt="Scene Example 2" />

## Additional Material Options {#translucent-options}

Besides `none` (no custom setting), `transparent` (fully transparent), and `translucent` (default translucent material), `--xr-background-material` supports:

- `regular` – Use together with `translucent` to differentiate adjacent blocks, such as a sidebar background.
- `thick` – Suitable for content nested inside another material background.
- `thin` – Good for interactive elements and highlighted selections.

<Image img={require("/assets/concepts/4-4.jpg")} alt="Scene Example 4" />
<Image img={require("/assets/concepts/4-3.png")} alt="Scene Example 4" />

Example from the [Techshop demo](/docs/introduction/built-on-the-existing-web-ecosystem#example-techshop):

```jsx showLineNumbers {2,5,17,19-27}
        <div
          enable-xr
          className="list-meun w-full md:w-64 shrink-0">
          <div
            enable-xr
            className="list-meun-bg bg-white rounded-lg shadow-md p-4"
          >
            <h2 className="text-lg font-semibold text-gray-800 mb-4">
              Categories
            </h2>
            <ul className="space-y-2">
             {categories.map(
                (category, index) =>
                  category !== "All" && (
                    <li key={index}>
                      <button
                        enable-xr
                        style={
                          import.meta.env.XR_ENV === "avp"
                            ? selectedCategory === category
                              ? {
                                  "--xr-background-material": "thin",
                                }
                              : {
                                  "--xr-background-material": "thick",
                                }
                            : {}
                        }
```

The sidebar menu itself uses a translucent material background. Items inside the menu use `thin` or `thick` depending on whether they are selected, creating clear visual separation from the menu background.

<Image img={require("/assets/guide/2-5.jpg")} alt="Scene Example 2" />

## Content Visibility and Opacity {#opacity}

For spatialized HTML elements with a translucent background, you can still use the CSS `display` and `visibility` properties to control the visibility of the whole element.
The CSS `opacity` property continues to affect the entire element, including both the material background and the foreground content.

## Stacking Order {#stacking-order}

If a spatialized HTML element is **NOT** [elevated](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements), it remains **part of the plane of its parent element**. That plane can be the whole window scene's plane, or a new plane created by an elevated parent element.

Multiple HTML elements located on the **same plane** follow normal DOM order to decide which one covers the other. For sibling nodes, later nodes cover earlier ones.

Within the same [stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Stacking_context) element (for example, an element that uses `position` or `transform`), you can also use `z-index` to change the stacking order.

Current WebSpatial SDKs have one limitation:

When overlap occurs, spatialized HTML elements always cover non-spatialized HTML elements.

Therefore, to let an HTML element cover a spatialized element, you must spatialize the former as well.

As a result, only the stacking order **among spatialized elements on the same plane** is relevant. There is no stacking order between those spatialized elements and other non-spatialized elements on that plane (because the spatialized ones always cover the others). The regular `z-index` API cannot help in that case.

To bridge the gap, WebSpatial SDK introduces a transitional API: `--xr-z-index` (this property's value is an integer).

Multiple spatialized HTML elements inside the **same** spatialized element can use `--xr-z-index` to change their relative stacking order.

- The parent spatialized element acts like a stacking context.
- In the nesting structure between the parent and its children, there must not be another spatialized element acting as an intermediate parent.

Remember, `--xr-z-index` **only** changes stacking order on the **same plane**. It **does NOT move elements along the Z-axis** and is completely separate from the [Elevate 2D Elements](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements) API.

---

// File: development-guide/using-the-webspatial-api/elevate-2d-elements

# Elevate 2D Elements

:::info

Basic concepts:

- [Spatialized Elements and 3D Container Elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements)

:::

:::note

Because the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) currently offers only a [React SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#react-sdk), all examples in this document use React.

APIs referenced in this section:

- `position: absolute`, `position: fixed`, `position: relative`
  - `--xr-back`
- `transform`
  - `translateZ()`, `translate3d()`
  - `rotateX()`, `rotateY()`, `rotate3d()`
  - `scaleZ()`, `scale3d()`
- `enable-xr-monitor`

:::

When an HTML element has [spatialization enabled](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements), it still sits on the web page plane inside a [Window Scene](/docs/core-concepts/scenes-and-spatial-layouts), participating in the original HTML/CSS layout flow. Its X and Y positions and dimensions - [determined by existing CSS properties and layout rules](/docs/core-concepts/spatialized-elements-and-3d-container-elements#2d-elements) - remain unchanged.

On top of that baseline, a spatialized HTML element can use the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) to move, transform, and lay itself out along the Z-axis in front of the web page plane. This "elevation" brings the web content into 3D space and gives the web page visual depth.

Multiple spatial APIs can achieve this elevation and can be grouped into three categories based on how they affect the layout flow.


## Out-of-layout-flow API {#affect-layout}

This category of APIs makes the HTML element completely leave the normal layout flow, meaning it no longer occupies its original position.

<a id="position-absolute"></a>

### `position: absolute`

With absolute positioning, the element is positioned relative to the nearest ancestor [containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Containing_block#identifying_the_containing_block) - an ancestor whose `position` value is not `static`, or one that has a `transform` property. If no such ancestor exists, it is positioned relative to the entire window.

<Image img={require("/assets/guide/3-1.jpg")} alt="Scene Example 3" />
<Image img={require("/assets/guide/3-2.jpg")} alt="Scene Example 3" />

In this mode, there are four CSS properties in the current web standard that let you "move" (position) an element in the four directions along the X and Y axes:

- `top`: moves downward along the Y-axis
- `bottom`: moves upward along the Y-axis
- `left`: moves rightward along the X-axis
- `right`: moves leftward along the X-axis

<Image img={require("/assets/guide/3-3.jpg")} alt="Scene Example 3" />

The [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) adds a new CSS property that positions the element along the Z-axis:

- `--xr-back`: moves (positions) forward along the Z-axis

`--xr-back` accepts **unit-less integers** that represent distances in native physical-space units (pt, where 1360 pt ≈ 1 meter).

In the current WebSpatial SDK, the value is interpreted relative to the **nearest ancestor spatialized element**. If none exists, it is relative to the **original web page plane**. Conceptually:

- If a spatialized element contains another absolutely positioned spatialized element (regardless of intermediate non-spatialized elements), the child's initial Z position is the **plane of that ancestor**. Think of it as a "back surface" from which `--xr-back` moves forward.
- If an absolutely positioned spatialized element has no ancestral spatialized elements, its initial Z position ("back surface") is the **web page plane of the entire window scene**.

:::info
In a future Web standard, a `back` property should behave like `top`/`bottom`/`left`/`right`, positioning relative to the nearest [containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Containing_block#identifying_the_containing_block).

To keep your WebSpatial code forward-compatible, best practice today is:
If a spatialized element has absolutely positioned spatial children and you want the parent to serve as the Z-axis origin for their positioning, then you should at least set `position: relative` on the parent (if it's not already `absolute` or `fixed`), so it becomes a containing block.

:::

Example based on the [Quick Example](/docs/quick-example/):

```css
html.is-spatial {
  background-color: transparent;
  // diff-remove
  --xr-background-material: transparent;
  // diff-add
  --xr-background-material: translucent;

  .count-card {
    --xr-background-material: thick;
    position: relative;

    p {
      --xr-background-material: transparent;
      // diff-add
      position: absolute;
      // diff-add
      bottom: -10px;
      // diff-add
      left: 0;
      // diff-add
      right: 0;
            // diff-add
      --xr-back: 20;
    }
  }
```

The `<p>` text is positioned on the Y-axis relative to its containing block `.count-card`, which is `relative`.

On the Z-axis, `--xr-back` also positions the `<p>` relative to the plane of `.count-card`, which is both a semi-transparent spatialized element and a containing block.

<Image img={require("/assets/guide/3-4.jpg")} alt="Scene Example 3" />


### `position: fixed` {#position-fixed}

With fixed positioning, the element is positioned against the [initial containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Containing_block#identifying_the_containing_block) (effectively the page plane of the window scene) and does not scroll with the page.

Just like absolute positioning, spatialized elements may use the four CSS properties on X and Y and the WebSpatial `--xr-back` on Z. Note that in this case, the initial Z position is **always the web page plane of the window scene**.

Example from the [Techshop demo](/docs/introduction/built-on-the-existing-web-ecosystem#example-techshop):

```css {6-16}
  .navbar {
    @apply mx-auto;
    --xr-background-material: translucent;
    border-radius: 50px;
    width: 1000px;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    --xr-back: 50;
  }

  .list-meun {
    position: fixed;
    top: 200px;
    left: 0;
```

The top bar and side bar are fixed; the product list remains in the page flow. Shrinking the window with the drag handle clips the list, which scrolls, while the top bar and side bar stay in place.

<Image img={require("/assets/guide/3-5.jpg")} alt="Scene Example 3" />

Clicking "View Details" opens a new product-detail window scene:

```css {highlight=5-9}
.product-detail-info {
  --xr-background-material: translucent;
  border-radius: 50px;
  padding: 50px;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  --xr-back: 20;
  margin: auto;
  width: 400px;
}
```

While the page scrolls, the left product image scrolls too, but the right info panel remains fixed.

<Image img={require("/assets/guide/3-6.jpg")} alt="Scene Example 3" />


## In-layout-flow API {#not-affect-layout}

This category of APIs do not affect the normal layout flow. The HTML element still occupies its original space in the layout, and its size is still controlled by the layout flow.


### `position: relative` - change only the position {#position-relative}

With relative positioning, the element can move along X and Y using the four CSS properties.

<Image img={require("/assets/guide/3-7.jpg")} alt="Scene Example 3" />

It can also move along Z with `--xr-back`. The initial Z position is **the plane where the element originally sits**, which works as the "back surface."

Example based on the [Quick Example](/docs/quick-example/):

```css
html.is-spatial {
  background-color: transparent;
  // diff-remove
  --xr-background-material: transparent;
  // diff-add
  --xr-background-material: translucent;

  .link-card {
  // diff-remove
    --xr-background-material: translucent;
  // diff-add
    --xr-background-material: thin;
    border-radius: 20px;
  // diff-add
    position: relative;
  // diff-add
    --xr-back: 50;
  // diff-add
    top: 20px;
  // diff-remove
    transform-origin: top left;
  // diff-remove
    transform: translateZ(30px) rotateX(30deg);
```

The `.link-card` is below `.count-card` in the original flow. In relative positioning mode, `--xr-back` moves it 50 units forward along Z while leaving its X/Y position untouched.

<Image img={require("/assets/guide/3-8.jpg")} alt="Scene Example 3" />

Another example from the [Quick Example](/docs/quick-example/):

```css
.count-card {
  --xr-background-material: thick;
  position: relative;
  --xr-back: 50;

  p {
    --xr-background-material: transparent;
    position: absolute;
    bottom: -10px;
    left: 0;
    right: 0;
    --xr-back: 20;
  }
}
```

`.count-card` moves 50 units forward in Z with relative positioning, while keeping its original X and Y position. Inside it, an absolutely positioned `<p>` moves an additional 20 units forward relative to the `.count-card` plane.

<Image img={require("/assets/guide/3-9.jpg")} alt="Scene Example 3" />

### CSS Transform - change position and shape {#css-transform}

CSS Transform leaves the element's original position, size, and layout relations intact, modifying only the rendered image via a matrix.

Standard CSS already allows transforms along all three axes, but depth effects are projected onto the 2D page, meaning the final visual outcome lacks actual spatial depth.

<p className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-7.jpg")} alt="" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-8.jpg")} alt="" />
  </div>
</p>

The WebSpatial SDK reuses the existing CSS Transform API. For non-spatial HTML elements, transforms along the Z-axis continue to be projected onto the flat page. But for spatial HTML elements, Z-axis transforms actually move them into 3D space.

The X/Y/Z origin is **always the plane where the element originally sits**. `transform-origin` can shift the origin in X and Y, but never in Z.

Spatialized elements treat that plane as the "back surface," letting the transformed image extend into the space in front.

<Image img={require("/assets/guide/3-13.png")} alt="Scene Example 3" />

`transform: perspective()` becomes unnecessary for spatialized elements since there's no need to define the projection.

Spatial elements support three types of CSS Transform that affect the Z-axis:

- `translateZ()`, `translate3d()`: displacement. Similar to `--xr-back`, originating from the back surface.
  > Note that the unit for `translateZ()` is still the same as before.
- `rotateX()`, `rotateY()`, `rotate3d()`: rotation. Rotating around X or Y pushes parts of the element into 3D space.
- `scaleZ()`, `scale3d()`: scaling along Z.

:::warning
`skew` is not supported.
:::

Example based on the [Quick Example](/docs/introduction/built-on-the-existing-web-ecosystem#example-techshop):

```css
html.is-spatial {
  background-color: transparent;
  // diff-remove
  --xr-background-material: transparent;
  // diff-add
  --xr-background-material: translucent;

  .link-card {
  // diff-remove
    --xr-background-material: translucent;
  // diff-add
    --xr-background-material: thin;
    border-radius: 20px;
    position: relative;
    --xr-back: 50;
    top: 20px;
    transform-origin: top left;
  // diff-add
    transform: translateZ(30px) rotateX(30deg);
```

`.link-card` first moves 50 units forward via `--xr-back`, then applies a transform: it moves another 30 px forward (automatically converted to pt) and rotates 30 degrees outward around its top edge.

<Image img={require("/assets/guide/3-14.jpg")} alt="Scene Example 3" />

Example from [Techshop demo](/docs/introduction/built-on-the-existing-web-ecosystem#example-techshop):

```css {5-6}
.list-meun {
  position: fixed;
  top: 200px;
  left: 0;
  transform-origin: top left;
  transform: translateZ(320px) rotateY(80deg);
}
```

The side menu is fixed at the far left, then transformed: it moves 320 px forward on Z (converted to pt) and rotates 80 degrees inward around its left edge.

<Image img={require("/assets/guide/3-15.jpg")} alt="Scene Example 3" />


## Layout-dependent API {#with-layout}

These APIs change the parent's layout flow so that children are laid out from back to front along the Z-axis, assigning Z positions through layout relationships.

They are **not yet supported** in the current WebSpatial SDK.


## Dynamic changes to the layout flow {#dynamic-change}

As noted at the start, once an element is spatialized it still lives in the original layout flow. Its position and size on the X and Y axes - based on regular CSS properties and layout rules - stay the same.

Updates in React may dynamically change CSS and layout, altering a spatialized element's X/Y position or size - whether or not the element is elevated.

[WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) automatically detects style changes on the spatialized element itself.

But if a layout change in a parent element causes a spatialized element's X/Y position or size to change, the WebSpatial SDK won't auto-detect those changes yet (for performance reasons)

To handle this, the SDK provides a temporary marker, `enable-xr-monitor`. Add it to a parent to activate auto-detection. If the parent's styles or internal layout change, WebSpatial will update its spatialized children's X/Y positions and sizes accordingly.

Example:

```jsx showLineNumbers {9,11}
function CardList() {
  const [showFirstCard, setShowFirstCard] = useState(true);

  const onClick = () => {
    setShowFirstCard(prevState => !prevState);
  };

  return (
    <div enable-xr-monitor>
      {showFirstCard && <div>first card</div>}
      <div enable-xr>second card</div>
      <button onClick={onClick}>toggle</button>
    </div>
  );
}
```

If "first card" disappears, the spatialized "second card" automatically shifts upward along Y.

---

// File: development-guide/using-the-webspatial-api/manage-multiple-scenes

# Managing Multiple Scenes

:::info

Basic concepts:

- [Scenes and Spatial Layouts](/docs/core-concepts/scenes-and-spatial-layouts)

:::

:::note

Because the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) currently offers only a [React SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#react-sdk), all examples in this document use React.

APIs referenced in this section:

- `xr_main_scene`
  - `default_size`
- `start_url`
- `scope`
- `<a>`
- `window.open`
- `initScene()`, `window.xrCurrentSceneDefaults`
  - `defautSize`
- `windowProxy.close()`

:::

A WebSpatial app always starts from a [Start Scene](/docs/core-concepts/scenes-and-spatial-layouts#start-scene), which loads the first [web page](/docs/core-concepts/scenes-and-spatial-layouts#scenes-in-webspatial) of the current run. Starting from this page, you can open additional pages in new Scenes, so the app is composed of multiple [Scenes](/docs/core-concepts/scenes-and-spatial-layouts).

## Managing the Start Scene {#start-scene}

As the starting point of the entire WebSpatial app, the Start Scene is created and initialized entirely by native code (for example, the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk)). **Web code only runs after this Start Scene already exists.**

Therefore, the type and [initialization settings](/docs/core-concepts/scenes-and-spatial-layouts#scene-init) of the Start Scene can be managed only in the [Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa).

The WebSpatial SDK adds a new manifest property, `xr_main_scene`, that lets you specify [initialization settings](/docs/core-concepts/scenes-and-spatial-layouts#scene-init) for the Start Scene.

Example from the [Quick Eample](/docs/quick-example/):

```json5
  "start_url": "/",
  "xr_main_scene": {
    "default_size": {
      "width": 500,
      "height": 1000
    }
  }
```

In this demo, the Start Scene originally used the size shown in the left image (landscape layout). After adding the configuration above to the Web App Manifest, the Start Scene switches to the portrait layout shown in the right image.

<p className="row">
  <div className="col col--6">
    <Image img={require("/assets/concepts/3-28.png")} alt="" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/concepts/3-29.png")} alt="" />
  </div>
</p>

:::note

In the current WebSpatial SDK:

- `xr_main_scene` only supports the `default_size` setting. More options will be added later.
- Only [Window Scenes](/docs/core-concepts/scenes-and-spatial-layouts#scenes-window) are supported for now. Other Scene types such as [Volume Scenes](/docs/core-concepts/scenes-and-spatial-layouts#scenes-volume) are not yet supported, so there are no manifest properties for the type of the Start Scene.

:::

The URL loaded in the Start Scene is the first URL opened and run within the WebSpatial app.

By default, it is determined by the [`start_url`](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) in the Web App Manifest.

The combination of the Web App Manifest's [`scope`](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#scope) and [`start_url`](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#start-url) clearly defines which URLs belong to this WebSpatial app.

The [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) automatically registers these URLs with the system so that they open in the corresponding WebSpatial app instead of a browser.

If the app is launched from one of these URLs, the Start Scene loads that specific URL instead of the `start_url`.

## Creating a New Scene {#new-scene}

All later scenes in a WebSpatial app are created by web code. In the Start Scene, and in every subsequent Scene, you can create new Scenes with web code.

The method is exactly the same as opening a link in a new window on a standard website:

- `<a href={newSceneUrl} target="_blank">`
- `<a href={newSceneUrl} target="newSceneName">`
- `window.open(newSceneUrl);`
- `window.open(newSceneUrl, "newSceneName");`

Two important notes:

- The link URL (for example, `newSceneUrl` above) **must** match the manifest's [`scope`](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest#scope), meaning it is part of the current WebSpatial app. Otherwise, the URL opens in the browser rather than creating a new Scene in the app.
- If you supply a window name (for example, `newSceneName` above) and a same-named Scene already exists and is still open, no new Scene is created. Instead, that Scene navigates to the new URL (equivalent to a URL jump inside the existing Scene). This behavior is the same as how multiple windows work in regular browsers.

:::warning
**Best practice:** Once a window name has been used, continue using that name only in the same parent window. Do not reuse the name from another windows. Otherwise, according to web standards, in those windows you might either not be able to reach the same-named window, or worse, your current window might unexpectedly become the parent of that window, which breaks the original parent's access.
:::

Example from the [Quick Example](/docs/quick-example/):

```jsx {4,11}
<div className="card" style={{ marginTop: "0px" }}>
  <h2>Open Second Page</h2>
  <p>
    <Link to="/second-page" target="_blank">
      Open Second Page with a Link
    </Link>
  </p>
  <p>
    <button
      onClick={() => {
        window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
      }}>
      Open Second Page with a Button
    </button>
  </p>
</div>
```

Clicking the link or the button opens new Scenes. Every Scene shows the content of `/second-page`, because that URL is opened in each new scene. Clicking the link multiple times produces multiple Scenes. Clicking the button multiple times produces a single Scene, because the `window.open` call gives it the window name `"secondScene"`.

<video
  src="https://static.webspatial.dev/multi-scenes.mp4"
  autoPlay
  loop
  muted
  playsInline
  style={{ width: '100%', height: 'auto' }}
/>

---

Because Scenes in spatial apps are [centrally managed](/docs/core-concepts/scenes-and-spatial-layouts) by the operating system, developers cannot arbitrarily control them. Instead, developers can only set the **desired initial values** for some scene properties at creation timed, the OS decides whether to honor them. After creation, these properties **cannot be changed by code** and are determined only by the OS and the user.

Current web standards weren't designed with spatial apps in mind, so there's no concept of scene initialization and no suitable standard API.

> The `windowfeatures` parameter in `window.open` might look like it can set window size, but those window properties can be changed at any time by code. They're not the same as scene initialization properties and not suitable here.

The WebSpatial SDK therefore provides two new APIs specifically for initializing new scenes:

### `initScene()` {#init-scene}

Call this API in the parent page to specify initialization settings for a soon-to-be-created scene.

```jsx
import { initScene } from "@webspatial/react-sdk";

initScene("newSceneName", defaultConfig => {
  return {
    ...defaultConfig,
    defaultSize: {
      width: 900,
      height: 700,
    },
  };
});
window.open(newSceneUrl, "newSceneName");
```

- To use this API, the new Scene must have a name (the window name in current web standards).
- You must call this API **before** creating the Scene, in **the same page** (the parent).
- Later, you must create the Scene **in the same page using the same name** for the settings to take effect.
- If initialization settings are provided in advance via this API, the new Scene is created immediately, without entering a loading or waiting state.
- After the Scene exists, calling this API again with the same name does not affect the existing Scene. If you later close the existing Scene and reopen a same-named Scene from the same parent, the last settings from this API call are used.

:::warning
Following the best practice above, if you provide initialization settings for a name in one page, you should only create Scenes with that name in the same page. Creating from another page can miss the settings and cause unexpected behavior.
:::

### `window.xrCurrentSceneDefaults` {#current-scene-defaults}

This hook lets a web page supply initialization settings for its own Scene.

```jsx
window.xrCurrentSceneDefaults = async defaultConfig => {
  const { width, height } = await requestDatabase();
  return {
    ...defaultConfig,
    defaultSize: {
      width,
      height,
    },
  };
};
```

- Use this API only within the page opened in the new Scene.
- It is a hook: you need to provide it **before the page is ready** so the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) can use it to retrieve the desired scene initialization properties from the web page.
- If no initialization properties were provided in advance, the new Scene first enters a waiting state. It loads the page in the background and, before finishing, tries to read the hook. If the hook returns properties, those are used; otherwise, defaults are used.
- If the hook returns an async function, the waiting state lasts until the function resolves or times out.
  :::tip
  One use case: the new page fetches different initialization properties from a server. For example, each article loaded from the server may have a window size suited to its content.
  :::

:::note

In the current WebSpatial SDK:

- Both APIs only support the `defaultSize` setting right now. More options will be added.
- Only [Window Scenes](/docs/core-concepts/scenes-and-spatial-layouts#scenes-window) are supported for now. Other Scene types such as [Volume Scenes](/docs/core-concepts/scenes-and-spatial-layouts#scenes-volume) are not yet supported, so there are no manifest properties for the type of the Start Scene.

:::

Example based on the [Quick Example](/docs/quick-example/):

```jsx
                <h2>Open Second Page</h2>
                <p>
                  <Link
                    to="/second-page"
                    // diff-add
                    target="_blank"
                    enable-xr
                  >
                    Open Second Page with a Link
                  </Link>
                </p>
                <p>
                  <button
                    onClick={() => {
                      // diff-add
                      initScene("secondScene", prevConfig => {
                      // diff-add
                        return {
                      // diff-add
                          ...prevConfig,
                      // diff-add
                          defaultSize: { width: 500, height: 500 },
                      // diff-add
                        };
                        // diff-add
                      });
                      window.open(
                        `${__XR_ENV_BASE__}/second-page`,
                        // diff-add
                        "secondScene",
                      );
                    }}>
                    Open Second Page with a Button
                  </button>
                </p>
```

When you click the link, no window name is supplied, so no initialization properties can be provided in advance. The new Scene enters the waiting state, tries to read `window.xrCurrentSceneDefaults`, finds none, and is created with defaults (left window in the image).

When you click the button, `initScene()` supplies initialization properties for the window name `"secondScene"`. The subsequent `window.open` call skips the waiting state and creates the Scene directly with those properties (right window in the image).

<Image img={require("/assets/concepts/3-30.png")} alt="Scene Example 3" />

## Managing Multiple Scenes {#multi-scenes}

All Scenes after the Start Scene are created by web code, and each Scene in the app is likewise managed by web code.

After a Scene is created, the operating system controls its size and position; code cannot change these. Scene management therefore focuses on closing Scenes and passing data.

Closing is the same as closing a window on a standard website.

For any newly created Scene, it can close itself by just calling `window.close()` in its own page.

But the Start Scene can't close itself this way, it can only be closed by the user.

If all other Scenes in the WebSpatial app are closed and only one is left, that last Scene can't close itself too, only the user can close it manually.

If a Scene wants to close other Scenes, it can only close the ones for which it holds a window reference (WindowProxy), according to web standards.

You can capture the WindowProxy when opening the Scene and later call `close()` on it.

```js
const newSceneWindowProxy = window.open(newSceneUrl);
const newSceneWindowProxy2 = window.open(newSceneUrl, "newSceneName");
newSceneWindowProxy.close();
newSceneWindowProxy2.close();
```

From a child scene, you can obtain the parent's WindowProxy via `window.opener`.

```js
opener.close();
```

To send data between Scenes, continue to use existing web APIs such as:

- `postMessage` (safe messaging between Scenes with a WindowProxy)
- `BroadcastChannel` (broadcast messages among Scenes with the same origin)
- `MessageChannel` (create a private two-way channel between two Scenes)
- `localStorage` (share data across Scenes of the same origin and listen for changes via the `storage` event)
- `SharedWorker` (let multiple same-origin Scenes share a background worker and communicate through it)

---

// File: development-guide/using-the-webspatial-api/add-3d-content

# Add 3D Content

:::warning
In testing. Documentation coming soon.
:::

---

// File: development-guide/using-the-webspatial-api/index

# Using the WebSpatial API

:::info
The [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) is currently available only in [React projects](/docs/development-guide/web-projects-that-support-webspatial) that [have the WebSpatial SDK installed](/docs/development-guide/enabling-webspatial-in-web-projects):
:::

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: development-guide/web-projects-that-support-webspatial/creating-new-web-projects

# Creating a New Web Project

:::tip
You can also start from [existing Web projects](/docs/development-guide/web-projects-that-support-webspatial/)
:::

## Modern Web Project Essentials {#requirements}

To build a brand-new WebSpatial project from scratch, first create a modern Web project (currently React-only) that meets the following requirements:

- Use HTML APIs (for example, JSX) through a UI framework such as React
- Use CSS APIs through the same UI framework (supports [PostCSS, TailwindCSS](/docs/development-guide/web-projects-that-support-webspatial/adding-tailwindcss-and-postcss), CSS-in-JS, and other approaches)
- Manage project dependencies with npm or any npm-compatible package manager (like [pnpm](/docs/development-guide/web-projects-that-support-webspatial/adding-pnpm))
- Compile and build HTML and static web assets (JS, CSS, images, etc.) that run directly in desktop / mobile browsers
- Run a Web server that exposes URLs accessible from desktop / mobile browsers

## Project Templates for Getting Started {#templates}

Below are several options for creating a modern Web project that satisfies the requirements above. Any of these can serve as the starting point before you add the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial.md#webspatial-sdk).

:::note
Ensure Node.js is installed first. See the [official Node.js site](https://nodejs.org/en/download) for installation instructions.
:::

1. React + Vite

   ```bash npm2yarn
   npx create-vite --template react
   ```

2. React + Vite + TypeScript

   ```bash npm2yarn
   npx create-vite --template react-ts
   ```

3. React + Next.js

   ```bash npm2yarn
   npx create-next-app --js
   ```

4. React + Next.js + TypeScript

   ```bash npm2yarn
   npx create-next-app --ts
   ```

5. React + Rsbuild

   ```bash npm2yarn
   npx create-rsbuild --template react
   ```

6. React + Rsbuild + TypeScript

   ```bash npm2yarn
   npx create-rsbuild --template react-ts
   ```

7. React + Rspack

   ```bash npm2yarn
   npx create-rspack --template react
   ```

8. React + Rspack + TypeScript

   ```bash npm2yarn
   npx create-rspack --template react-ts
   ```

## Adding Other Common Features (Optional) {#other-features}

- [Add TailwindCSS + PostCSS](/docs/development-guide/web-projects-that-support-webspatial/adding-tailwindcss-and-postcss)
- [Add pnpm](/docs/development-guide/web-projects-that-support-webspatial/adding-pnpm)

---

// File: development-guide/web-projects-that-support-webspatial/adding-tailwindcss-and-postcss

# (Optional) Add TailwindCSS and PostCSS

TailwindCSS is a utility-first CSS framework that provides a large set of atomic classes to speed up UI development.
PostCSS is a tool for transforming CSS, allowing you to use upcoming CSS features today.

## Install dependencies {#install}

```bash npm2yarn
npm install -D tailwindcss postcss autoprefixer
```

## Generate configuration files {#config}

Run the following command to generate the TailwindCSS and PostCSS configuration files.

```bash npm2yarn
npx tailwindcss init -p
```

It will create `tailwind.config.js` and `postcss.config.js`.

Edit `tailwind.config.js` and specify the template paths that TailwindCSS should scan.

```js
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

## Integrate with your web build tool {#build}

Finally, add the necessary configuration to your web build tool.
For example, if you are using Vite, add the TailwindCSS plugin in `vite.config.js`.

```js
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
  plugins: [
    tailwindcss(),
```

---

// File: development-guide/web-projects-that-support-webspatial/adding-pnpm

# (Optional) Add pnpm

pnpm is a drop-in replacement for npm. It saves disk space by using hard links and symlinks, and it delivers faster install times.

## Add an `.npmrc` file {#npmrc}

Create an `.npmrc` file in the project root.

```ini
shamefully-hoist=true
strict-peer-dependencies=false
auto-install-peers=true
```

## Update `.gitignore` {#gitignore}

Add the appropriate pnpm-related entries to `.gitignore`.

```
.pnpm-store/
.pnpm-state.json
.pnpmfile.cjs
```

## Verify pnpm is installed globally {#install}

Make sure pnpm is installed globally on your system.

:::tip

You can install it with Corepack,

```bash
corepack enable pnpm
```

or directly with npm.

```bash
npm install -g pnpm
```

:::

## Generate `pnpm-lock.yaml` {#lock}

When you install dependencies with pnpm for the first time, it automatically creates `pnpm-lock.yaml`.

```bash
rm -rf node_modules
pnpm install
```

## (Optional) Add npm scripts {#npm-scripts}

You can add helper npm scripts in `package.json` to simplify common pnpm commands.

```json5
"install:clean": "rm -rf node_modules && pnpm install",
"install:update": "rm -rf node_modules pnpm-lock.yaml package-lock.json && pnpm install",
```

---

// File: development-guide/web-projects-that-support-webspatial/index

# Web Projects That Support WebSpatial

WebSpatial currently uses a [Hybrid approach](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) that allows mainstream Web projects to immediately leverage the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) to gain spatial-computing capabilities on XR platforms. This does not affect how those projects run on existing desktop/mobile platforms or in regular browsers, thereby preserving their original cross-platform capabilities.

:::info

Besides the inherent cross-platform capabilities of standard websites, the new spatial features introduced by WebSpatial also work across different spatial-computing platforms. The following lists both currently supported and those planned for future support:

- ✅ visionOS devices (such as Vision Pro)
- ⏳ Android XR devices (no commercial hardware yet, planned)
- ⏳ Meta Quest / Horizon OS devices (APIs missing, planned)
- ⏳ PICO devices (planned)

:::

## Using Existing Web Projects {#existing-projects}

Any Web project that meets the following requirements can use the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) out of the box:

1. **The current UI is built with React and Web standards, running directly in mainstream browser engines.**

   - By simply [configuring `jsx-runtime`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/configure-js-ts-compiler) - which does [NOT affect the site's appearance or performance on other platforms](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website) - you can call WebSpatial's HTML/CSS-based API inside React. This works with [PostCSS, Tailwind CSS, CSS-in-JS, and other CSS tooling](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#css).
   - Non-React projects can gain spatial capabilities via WebSpatial's [Core SDK](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk#core-sdk) (documentation coming soon).
   - We hope to work with the community to add support for more UI frameworks on top of the Core SDK in the future. Contributions are welcome!

2. **The current UI implementation generally follows [React's guidelines and best practices](https://react.dev/reference/rules).**

   - UI code is declarative, describing UI state rather than imperatively manipulating it, let React decide when to update state and when to render.
   - State changes rely on one-way data flow and immutable data (data always flows from parent to child and is not mutated by child components).
   - Side effects are avoided inside React components or are controlled with React APIs to prevent them from running during rendering.
   - If parts of the project bypass React and manipulate the DOM directly, avoid using the React-based WebSpatial API on those parts to prevent conflicts.

3. **The final web code is built using one of the following mainstream Web build tools.**

   - Vite (It's recommended to use the WebSpatial's [Vite plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools#vite))
   - Next.js (It's recommended to use the WebSpatial's [Next.js plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools#next))
   - Rsbuild (It's recommended to use the WebSpatial's [Rsbuild plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools#rsbuild))
   - Rspack (It's recommended to use the WebSpatial's [Rspack plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools#rspack))
   - Webpack (Docs to be added)

4. **The project's web server (including any third-party web services) can control HTML output and static Web assets.**
   - This server can serve [special HTML tailored for WebSpatial](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website) for every URL on your site. That HTML loads static web files specifically for the [WebSpatial App Shell](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk), like JS files that include the WebSpatial SDK.

If you want to add the WebSpatial API to an existing Web project, you can skip the rest of this chapter and jump to the next main chapter: [Enabling WebSpatial in Web Projects](/docs/development-guide/enabling-webspatial-in-web-projects/)

## Creating a New WebSpatial Project {#new-projects}

If you prefer to start a brand-new web project with WebSpatial support from day one, or build a fresh demo to experiment with the WebSpatial API and experience WebSpatial apps, you can follow the rest of this chapter to generate a standard Web site project that has not yet integrated WebSpatial, as your starting point.

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: introduction/new-powers-for-xr-apps

# New Powers for XR Apps

On XR platforms such as Vision Pro, Meta Quest, and PICO, apps (including Web apps) gain brand-new capabilities and enormous potential. Even without cutting-edge features like full immersion or environment blending, XR apps already offer the following clear advantages in **existing mainstream user cases**:

## Bigger Than the Biggest Screen {#bigger}

The software interface expands from a bounded display to the entire 3D space around the user, giving interfaces **more room** to work with and allowing more interfaces to **coexist and collaborate**.

1. Apps built around large screens and multiple windows achieve higher **efficiency**.
2. The "living space" for apps grows, so more apps can act as sidekicks or companions and **no longer have to carry the entire user scenario alone**.
3. Content that used to feel ordinary - HD images, data visualizations, videos - gains **fresh appeal** when presented in a spacious environment.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-1.jpg")} alt="intro-1-1" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-2.png")} alt="intro-1-2" />
  </div>
</div>

## Beyond the 2D Plane {#beyond-2d}

Both the GUI and the content **no longer have to stay flat**; they can be built and extended in 3D space like real-world objects.

1. 3D assets can be displayed and manipulated stereoscopically in space. Users can **directly** view them from any angle (even "enter" them) and interact with their hands, instead of fighting with inefficient 3D viewers trapped in **flat viewports or canvases**.
2. GUIs no longer have to crowd into a single window and rely on borders, shadows, padding, or background colors to differentiate elements. They can be broken down into 3D space to achieve **true visual hierarchy and information separation** while keeping themselves **as clean and minimal as possible**.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-3.png")} alt="intro-1-3" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-4.jpg")} alt="intro-1-4" />
  </div>
</div>

## A Leap Forward in Human-Computer Interaction {#interaction}

Interaction gains more possibilities: it is more natural and intuitive, more flexible and diverse, and easier to tailor to specific scenarios.

1. Users can handle digital content **like real objects** - grab, drag, stretch, squeeze, and rotate it directly - without **extra control panels or specialized gestures** to learn.
2. No more flinging a mouse across the screen or poking at a touch panel with hands held up; most of the time **hands stay still** (choose with eye gaze, confirm with a pinch).
3. There is no need to buy or store dedicated hardware. Software alone can flexibly provide various **specialized input tools** (just as the iPhone implements its keyboard purely in software).

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-5.jpg")} alt="intro-1-5" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-6.gif")} alt="intro-1-6" />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-7.jpg")} alt="intro-1-7" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-1-8.jpg")} alt="intro-1-8" />
  </div>
</div>

---

// File: introduction/the-new-generation-of-spatial-apps

# The New Generation of Spatial Apps

With Apple's release of the next-gen XR OS, visionOS, and its new spatial-computing architecture ([Unified Rendering app model](https://developer.picoxr.com/news/multi-app-rendering/)), the [long-standing bottlenecks of traditional XR apps](#traditional-xr-apps) have been fundamentally addressed.

The new generation of XR apps - **spatial apps** - are not cut off from the 2D apps on desktop and mobile platforms. Instead, they extend the advantages of those 2D apps, adding [**spatial capabilities**](/docs/core-concepts/shared-space-and-spatial-apps) that bring **optional enhancements** on spatial-computing platforms and free them from flat 2D windows.

<div className="row">
  <div className="col col--6">
    <video
      src="https://static.webspatial.dev/intro-2-1-1.mp4"
      autoPlay
      loop
      muted
      playsInline
      style={{ width: '100%', height: 'auto' }}
    />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-2-2.jpg")} alt="intro-2-2" />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-2-3.jpg")} alt="intro-2-3" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-2-4.jpg")} alt="intro-2-4" />
  </div>
</div>

## Comparing Three App Types {#comparing}

:::info

In the comparisons below, <span className="advantage-mark">green background</span> means advantage and <span className="disadvantage-mark">red background</span> means disadvantage.

:::

### Multitasking {#comparing-multitasking}

- **Spatial apps**

  - <span className="advantage-mark">Can run and use **multiple apps that include 3D content** at the same time.</span>
  - <span className="advantage-mark">Can **quickly switch** between the currently focused apps.</span>
  - <span className="advantage-mark">Can **keep auxiliary apps open** while using a primary app.</span>

- **Desktop/Mobile apps**

  - Can run and use **multiple apps** at the same time.
  - <span className="advantage-mark">Can **quickly switch** between the currently focused apps.</span>
  - <span className="advantage-mark">Can **keep auxiliary apps open** while using a primary app.</span>

- **Traditional XR apps**
  - <span className="disadvantage-mark">Only one app with 3D content can run at a time.</span>
  - <span className="disadvantage-mark">Switching requires quitting the current app and launching the next, which is costly.</span>
  - <span className="disadvantage-mark">Cannot keep auxiliary apps (especially 3D apps) open while using a primary app.</span>

### Relationship with the OS {#comparing-os}

- **Spatial apps**

  - <span className="advantage-mark">An app can **own the entire 3D space** or only [**a local part of it**](/docs/core-concepts/scenes-and-spatial-layouts) such as its own [scene container (similar to a bounding box)](/docs/core-concepts/scenes-and-spatial-layouts), while the OS handles the rest.</span>
  - <span className="advantage-mark">Because the OS supplies most functionality and a unified experience, the app can **focus on its unique value**, so design and development costs stay low and package size is small.</span>

- **Desktop/Mobile apps**

  - Each app only handles part of what's shown on the screen (**the content within its own window**), while the OS handles the rest.
  - <span className="advantage-mark">Because the OS supplies most functionality and a unified experience, the app can **focus on its unique value**, so design and development costs stay low and package size is small.</span>

- **Traditional XR apps**
  - The app takes over the entire 3D space, rendering **all** visuals and features (excluding the OS's temporary flat overlays, like the global toolbar).
  - <span className="disadvantage-mark">The app must satisfy nearly all user needs on its own, so design and development costs are high, package size is large, and experiences are inconsistent across apps.</span>

### 3D Capability {#comparing-3d}

- **Spatial apps**

  - <span className="advantage-mark">The 2D and 3D content in the app can [**go beyond the flat window**](/docs/core-concepts/spatialized-elements-and-3d-container-elements) and be displayed throughout the 3D space.</span>
  - To let multiple apps [**share one 3D space (unified rendering)**](/docs/core-concepts/shared-space-and-spatial-apps#unified-rendering), different apps can't just implement arbitrary rendering mechanisms and freely draw their content without constraints. They must supply content via [OS-managed 2D/3D containers](/docs/core-concepts/scenes-and-spatial-layouts) and describe it with OS-understood APIs; the OS handles the rendering.

- **Desktop/Mobile apps**

  - <span className="disadvantage-mark">Both 2D and 3D content in the app must stay in a single plane (3D content is **projected** onto that plane).</span>

- **Traditional XR apps**
  - <span className="advantage-mark">2D and 3D content in the app can be shown **anywhere** in the app's **exclusive** 3D space.</span>

### Interaction Capability {#comparing-interaction}

- **Spatial apps**

  - <span className="advantage-mark">Leverage environment sensing, head tracking, hand tracking, and eye tracking to deliver [**truly natural interaction**](/docs/core-concepts/spatialized-elements-and-3d-container-elements#nature-interaction).</span>
  - <span className="advantage-mark">Need no controllers. Regardless of GUI type (2D or 3D) or distance, these apps default to using the most efficient, low-effort, and natural **eye-hand interaction**. The OS handles interaction implementation and visual effects, reducing app costs and keeping the user experience consistent.</span>

- **Desktop/Mobile apps**

  - <span className="disadvantage-mark">Interaction has evolved from mouse and keyboard to multi-touch, gradually approaching **natural interaction** in the physical world.</span>

- **Traditional XR apps**
  - <span className="advantage-mark">Leverage environment sensing, head tracking, hand tracking or XR controllers to allow further progress toward **natural interaction** beyond multi-touch on screens.</span>
  - For distant 2D GUIs, users must aim a pointer ray with a controller or hand, which feels **less natural and is less efficient** than than a mouse.

### Development Approach {#comparing-development}

- **Spatial apps**

  - <span className="advantage-mark">Built on [**2D GUI frameworks** enhanced with spatial features](/docs/introduction/built-on-the-existing-web-ecosystem).</span>
  - <span className="advantage-mark">Fit almost every business domain and app type (except a few heavy 3D niches) while building on the existing product/GUI design patterns and keep developing from there.</span>
  - <span className="advantage-mark">[APIs](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) are highly abstract, concrete, intuitive, and have a low learning curve.</span>
  - <span className="advantage-mark">Large potential base of developers ready to start building and strong integration with the open-source ecosystem.</span>

- **Desktop/Mobile apps**

  - Based on **2D GUI frameworks**.
  - <span className="advantage-mark">Fit almost every business domain and app type (except some 3D games) with existing product/GUI design patterns.</span>
  - <span className="advantage-mark">APIs are highly abstract, concrete, intuitive, and have a low learning curve.</span>
  - <span className="advantage-mark">Large developer base and thriving open-source ecosystem.</span>

- **Traditional XR apps**
  - Based on **3D game engines**.
  - <span className="disadvantage-mark">Few existing product/GUI design patterns for **non-gaming apps**.</span>
  - <span className="disadvantage-mark">APIs come from computer graphics, they are relatively **low level**, less intuitive, and have a steep learning curve.</span>
  - <span className="disadvantage-mark">The developer base and ecosystem are smaller, skewing toward paid tools with fewer high-quality open-source options.</span>

### Interaction Implementation {#comparing-interaction-tech}

- **Spatial apps**

  - <span className="advantage-mark">The OS provides [basic interaction events (for 2D)](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#content-interaction) and [advanced spatial interaction events (for 3D or 2D content)](/docs/core-concepts/spatialized-elements-and-3d-container-elements#spatial-interaction).</span>
  - <span className="advantage-mark">The OS renders common interaction visuals.</span>

- **Desktop/Mobile apps**

  - <span className="advantage-mark">The OS provides basic interaction events.</span>
  - <span className="advantage-mark">The OS renders the mouse cursor.</span>

- **Traditional XR apps**
  - <span className="disadvantage-mark">The app itself handles all interaction events on 2D or 3D content.</span>
  - <span className="disadvantage-mark">The app must render all visual effects and interaction indicators for controllers and hands.</span>
  - <span className="disadvantage-mark">[Building XR interaction is costly](https://developer.picoxr.com/document/web/webxr-vs-web3d/), requiring building from scratch or leveraging inconsistent XR toolkits.</span>

### UI Implementation {#comparing-gui-tech}

- **Spatial apps**

  - <span className="advantage-mark">The GUI is built from **UI components** (including [3D containers](/docs/core-concepts/spatialized-elements-and-3d-container-elements#3d-elements)).</span>
  - <span className="advantage-mark">The OS and framework render those components each frame; the app does not care about drawing.</span>
  - <span className="advantage-mark">Position and size of these UI elements are automatically decided based on their [**layout relationships** (like nesting hierarchy or order) and attributes](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements). Developers use them like **building blocks** - highly concrete and intuitive - allow developers to work entirely in code without the assistance of visual editors.</span>

- **Desktop/Mobile apps**

  - The GUI is built from **UI components**.
  - <span className="advantage-mark">The OS and framework render those components each frame; the app does not care about drawing.</span>
  - <span className="advantage-mark">Layout relationships and attributes determine position and size; developers think in **building blocks**, code-centric, no visual editor needed.</span>

- **Traditional XR apps**
  - The GUI is built from **graphics objects**.
  - <span className="disadvantage-mark">The app itself renders those objects each frame.</span>
  - <span className="disadvantage-mark">Position and size come from coordinates. Developers usually need visual editors to help make the rendering and using of these objects more clear and intuitive.</span>

## Problems with Traditional XR Apps {#traditional-xr-apps}

Before visionOS, apps on XR platforms were **completely different** from apps on desktop and mobile:

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-2-5.jpg")} alt="intro-2-5" />
    <p className="text--center">Desktop apps</p>
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-2-6.jpg")} alt="intro-2-6" />
    <p className="text--center">Traditional XR apps</p>
  </div>
</div>

From the comparison above, we can see that besides the three main advantages mentioned in [the previous section](/docs/introduction/new-powers-for-xr-apps), **traditional XR apps have downsides both in terms of user experience and development, losing many benefits of desktop/mobile apps**. Traditional XR development could not reuse existing app code, tools, and programming mindsets from mainstream platforms. This makes it harder to support diverse use cases and business domains, leads to fewer developers, and raises both the entry barrier and development costs.

---

// File: introduction/html-css-and-webxr

# HTML/CSS and WebXR

However, the problem that follows is, **the Web didn't automatically gain such spatial capabilities**.

## The Problem with HTML/CSS {#html-css}

**The Web is naturally friendly to multitasking, multi-window, and multi-app use.** Each web page can focus on its own content and single purpose, coexisting smoothly with the OS and other apps.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-1.jpg")} alt="intro-3-1" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-2.jpg")} alt="intro-3-2" />
  </div>
</div>

On desktop and mobile platforms, Web development relies on **the same 2D GUI technology** as native apps. Frameworks like React are popular, even the underlying tech - HTML, CSS, and JS based on the browser's layout engine - is also based on UI component (i.e., HTML elements), layout relationships, and a development paradigm that resembles building blocks and centers around code.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-3.jpg")} alt="intro-3-3" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-4.jpg")} alt="intro-3-4" />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-5.jpg")} alt="intro-3-5" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-6.jpg")} alt="intro-3-6" />
  </div>
</div>

However, HTML/CSS content is confined to the 2D plane of a browser window or WebView. It cannot enter 3D space. Its most APIs (i.e., CSS) are based on the X and Y axes. The few APIs that involve the Z axis, such as `translate3d` and WebGL, can only describe Z-axis effects **projected onto a 2D canvas**.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-7.jpg")} alt="intro-3-7" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-8.jpg")} alt="intro-3-8" />
  </div>
</div>

This situation for Web frameworks and HTML/CSS was the same as SwiftUI on iOS/iPadOS before visionOS arrived.

## The Problem with WebXR {#webxr}

On the other hand, Web 3D content built with WebGL or WebGPU can use a new Web standard API - [WebXR](https://developer.picoxr.com/document/web/introduce-webxr-standards/) - on spatial computing platforms to break out of the browser window, enter 3D space, and gain XR interaction capabilities from XR hardware (head tracking, hand tracking, and so on). In this way, the Web gains spatial capabilities comparable to OpenXR or Unity apps.

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-9.jpg")} alt="intro-3-9" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/intro/intro-3-10.jpg")} alt="intro-3-10" />
  </div>
</div>

But WebXR content faces issues identical to those of [traditional XR apps](/docs/introduction/the-new-generation-of-spatial-apps#traditional-xr-apps) built with OpenXR or Unity:

- WebXR content **cannot coexist with other XR apps**, and it **cannot even coexist with other 2D Web content in the same web page**. Once a WebXR session starts, it takes over rendering for the entire space, hiding the original web page and OS UI; the app itself must handle all interaction.
- Its all content and GUI must be built [**entirely with WebGL or WebGPU**](https://developer.picoxr.com/document/web/webxr-vs-web3d/), usually with a **Web 3D engine**. This approach is **completely disconnected** from mainstream Web development with HTML + CSS + JS. In mainstream internet domains, 2D Web GUIs satisfy requirements easily and tap into a huge stock of UI patterns, component libraries, and open-source ecosystems. **None of that can be used directly in WebXR development**. Devs have to start from scratch, reinvent UI with disparate 3D GUI experiments or re-implement familiar 2D GUIs via WebGL/WebGPU.

<Image img={require("/assets/intro/intro-3-11.jpg")} alt="intro-3-11" />
<Image img={require("/assets/intro/intro-3-12.jpg")} alt="intro-3-12" />

## Problem Summary {#summary}

WebXR is **incompatible with the mainstream Web-development ecosystem and cannot live alongside existing 2D Web content**, while the HTML/CSS tech used in mainstream Web development **lacks any spatial capability**.

---

// File: introduction/make-the-web-spatial-too

# Make the Web Spatial Too

**WebSpatial** is a set of [spatial APIs](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) built on top of the mainstream Web-development ecosystem and existing 2D Web. It enables the entire HTML/CSS-based Web world - billions of websites and Web apps, tens of millions of Web developers, and millions of open-source libraries - to step into the spatial era, **gaining spatial power on par with native spatial apps (like visionOS apps) while keeping all the advantages the Web already have**.

<iframe
  style={{
    aspectRatio: "4/3",
    width: "100%",
    height: "auto"
  }}
  src="https://www.youtube.com/embed/Bkef2HvkKhY?si=rjepUJPBFMy-bgLu"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerpolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### Position HTML Elements on the Z Axis {#position}

With WebSpatial, **HTML elements** can be laid out and positioned not only along the X and Y axes via CSS, but also [**along the Z axis in front of the web page**](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements):

<Image img={require("/assets/intro/intro-4-2.jpeg")} alt="image" />

### Transform HTML Elements in True 3D {#transform}

WebSpatial lets HTML elements [**rotate, scale, and warp along the Z axis in real space**](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements).

<Image img={require("/assets/intro/intro-4-3.jpg")} alt="image" />

For example, you can build an actual 3D cube using plain `div` elements:

<Image img={require("/assets/intro/intro-4-4.jpeg")} alt="image" />

### Material-Based Backgrounds {#material}

With WebSpatial, HTML elements can have backgrounds that are **[semi-transparent materials](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds) rendered in real time from the environment**, so regardless of the environment's color and lighting conditions, content stays legible.

You can also set the background of an element or an entire page window to a [**fully transparent material**](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds), making its contents appear to float and disperse in space.

<Image img={require("/assets/intro/intro-4-5.jpg")} alt="image" />

### Genuine 3D Elements for HTML {#3d-elements}

WebSpatial adds **[true 3D elements](/docs/core-concepts/spatialized-elements-and-3d-container-elements#3d-elements)** to HTML, allowing 3D content to appear directly in space:

<Image img={require("/assets/intro/intro-4-6.jpeg")} alt="image" />

These 3D elements can [**participate in layout alongside 2D elements**](/docs/development-guide/using-the-webspatial-api/add-3d-content), forming any mix of Web content and GUI:

<Image img={require("/assets/intro/intro-4-7.jpeg")} alt="image" />

### Multi-Scene Spatial Apps {#multi-scene}

A WebSpatial app can comprise multiple **[scenes](/docs/core-concepts/scenes-and-spatial-layouts)**, just like a native spatial app. These 2D + 3D (or pure 3D) scenes can be [**managed as standard Web windows**](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes), while also allowing for be [initialized with configurations specific to spatial computing platforms](/docs/core-concepts/scenes-and-spatial-layouts#scene-init).

<video
  src="https://static.webspatial.dev/multi-scenes.mp4"
  autoPlay
  loop
  muted
  playsInline
  style={{ width: '100%', height: 'auto' }}
/>

### 3D Containers with 3D Engine APIs (upcoming feature) {#3d-engine}

Among the 3D elements WebSpatial adds to HTML, there is a container type that lets you **render and control its 3D content via 3D engine APIs**. Web 3D programming is no longer limited to flat canvases or a handful of full-screen 3D games (including WebXR games that take over the whole 3D space). It can now be useful in multitasking scenarios and a far wider range of applications.

---

// File: introduction/built-on-the-existing-web-ecosystem

# Built on the Existing Web Ecosystem

While the mainstream Web ecosystem is ultimately built on HTML/CSS, most Web developers **do not work directly with raw HTML/CSS** when creating applications. Instead, they rely on **UI frameworks or full-featured application frameworks**. React is currently the most popular choice - developers use HTML through React's JSX API and component-based architecture, and CSS through APIs such as TailwindCSS, PostCSS, or CSS-in-JS.

To quickly put the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) into practice in the real world and meet the urgent needs of the Web ecosystem, the WebSpatial open-source project provides a **[WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) designed for Web frameworks (for example, React + Vite)**. This lets Web developers immediately start using the WebSpatial API within their framework's HTML (JSX) and CSS APIs, **without waiting for browser engines to ship these capabilities**.

In its first release, WebSpatial SDK offers **out-of-the-box support for [React projects](/docs/development-guide/web-projects-that-support-webspatial/)**.

:::info

We hope to work with the community to add support for more UI frameworks in the future. WebSpatial also offers a **framework-agnostic Core SDK composed solely of pure JS APIs**, so developers can implement the WebSpatial API in other frameworks or import specific spatial features directly from the Core SDK.

:::

You can call WebSpatial's [**HTML API**](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements) and [**DOM API**](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#dom) directly inside React JSX:

```jsx
// diff-remove
              <div className="card count-card">
// diff-add
              <div className="card count-card" enable-xr>
                <button onClick={() => setCount(count => count + 1)}>
                  count is {count}
                </button>
// diff-remove
                <p>
// diff-add
                <p enable-xr>
                  Edit <code>src/App.tsx</code> and save to test HMR
                </p>
              </div>
```

<!-- TODO：add examples for Model -->

You can also use WebSpatial's [**CSS API**](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements#css) in a React project together with TailwindCSS, PostCSS, Styled Components, and similar solutions:

```css
.count-card {
  // diff-add
  --xr-background-material: thick;
  position: relative;

  p {
    // diff-add
    --xr-background-material: transparent;
    position: absolute;
    bottom: -10px;
    left: 0;
    right: 0;
    // diff-add
    --xr-back: 20;
  }
}
```

You can use the **existing link element and window-related DOM APIs** in Web standards together with WebSpatial's new **[Scene Initialization](/docs/core-concepts/scenes-and-spatial-layouts#scene-init) API** - to treat and manage [scenes within spatial apps](/docs/core-concepts/scenes-and-spatial-layouts) as regular web page windows.

```jsx
                <p>
// diff-remove
-                 <Link to="/second-page">
// diff-add
+                 <Link to="/second-page" target="_blank">
                    Open Second Page with a Link
                  </Link>
                </p>
                <p>
                  <button
// diff-add
                    onClick={() => {
// diff-add
                      initScene("secondScene", prevConfig => {
// diff-add
                        return {
// diff-add
                          ...prevConfig,
// diff-add
                          defaultSize: {
// diff-add
                            width: 500,
// diff-add
                            height: 500,
// diff-add
                          },
// diff-add
                        };
// diff-add
                      });
                      window.open(
                        `${__XR_ENV_BASE__}/second-page`,
// diff-add
                        "secondScene",
                      );
                    }}>
                    Open Second Page with a Button
                  </button>
                </p>
```

You can manage **app-level configurations** such as the WebSpatial app's [start scene](/docs/core-concepts/scenes-and-spatial-layouts#start-scene), offline packaging, [native window UI](/docs/core-concepts/scenes-and-spatial-layouts#scene-menu), and app icons by using the **[Web App Manifest](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa/add-web-app-manifest) from the [PWA standard](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa)**.

```json5 {6-11} showLineNumbers title="public/manifest.webmanifest"
{
  "name": "TechShop - Premium Tech Products",
  "start_url": "/",
  "scope": "/",
  "display": "minimal-ui",
  "xr_main_scene": {
    "default_size": {
      "width": 1700,
      "height": 1200
    }
  },
  "icons": [
    {
      "src": "/icons/icon-1024x1024.png",
      "sizes": "1024x1024",
      "type": "image/png",
      "purpose": "maskable"
```

A Web project that integrates the WebSpatial SDK is still a **cross-platform website that conforms to Web standards**. Your existing development workflow, codebase, and best practices built on the mainstream Web ecosystem stay unchanged, and the UI, interactions, and performance on desktop and mobile platforms remain **unaffected**. The new WebSpatial APIs fit naturally alongside existing APIs and implementation methods, preserving cross-platform compatibility as well as your established development habits and mental models.

---

## Example - Techshop {#example-techshop}

Example project: https://github.com/webspatial/sample-techshop

The screenshots below show how this sample project looks on different platforms. Only the last screenshot runs as a [Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk) on visionOS and activates spatialized UI. All other screenshots show the project running directly in regular browsers that do **not** support the [WebSpatial API](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-api) (including Safari on visionOS).

<div className="row">
  <div className="col col--6">
    <p>Large Screen</p>
    <Image img={require("/assets/intro/techshop-desktop.png")} alt="Large Screen" />
  </div>
  <div className="col col--6">
    <p>Tablet</p>
    <Image img={require("/assets/intro/techshop-pad.jpg")} alt="Tablet" />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <p>Small Window</p>
    <Image img={require("/assets/intro/techshop-small.jpg")} alt="Small Window" />
  </div>
  <div className="col col--6">
    <p>Phone</p>
    <Image img={require("/assets/intro/techshop-phone.jpg")} alt="Phone" />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <p>visionOS Safari</p>
    <Image img={require("/assets/intro/techshop-safari.png")} alt="visionOS Safari" />
  </div>
  <div className="col col--6">
    <p>WebSpatial</p>
    <Image img={require("/assets/intro/techshop-spatial.png")} alt="WebSpatial" />
  </div>
</div>

---

// File: introduction/if-you-are-a-developer

# If You Are a {`___`} Developer

## 2D Web Developers {#web-developers}

If you are a 2D Web developer, WebSpatial lowers the **threshold** and **cost** of building spatial apps to almost nothing for you (especially when you already have existing Web App projects).

Although spatial-computing platforms and XR devices (including Vision Pro-like headsets that are becoming lighter and more affordable, and AI/AR glasses with rapidly advancing GUI capabilities) do not yet have the same large user base as desktop/mobile platforms, WebSpatial's **cross-platform support** and **low adaptation cost** let you confidently enter these next-gen computing platforms early. You can keep exploring and practicing user experience, UI design, functionality, and use cases while gaining experience and insights. Once opportunities emerge in these platforms or certain application areas, you will be ready to participate from day one.

You can publish your existing Web App in the spatial-computing platform's **app store**, gaining greater exposure, reputation, and sharing opportunities in a **less-competitive environment that is closer to some users**.

You can turn your existing Web App into an **"ultra-large-screen" experience** on spatial-computing platforms, fully leveraging the larger space to simplify the UI and enhance content.

You can enrich your existing Web App with **more vivid, intuitive and attractive 3D content and 3D GUI** on spatial-computing platforms.

You can give your existing Web App **more natural and diverse interaction methods** on spatial-computing platforms.

You can also activate **brand-new features and use cases designed specifically for XR users**, unlocking new possibilities for your existing Web App.

Once you are familiar with the API, you can create **entirely new apps for spatial-computing platforms at low cost** while preserving cross-platform compatibility for desktop and mobile, **serving every user group**.

## Native App Developers {#native-developers}

If you are a native spatial app developer, you can follow **existing best practices in mobile development** by embedding **WebView containers powered by WebSpatial** in your native spatial app and letting the Web developers in your team maintain **dynamic content and frequently updated GUI** in your app.

With this kind of WebView, Web developers can implement not only 2D content and 2D GUI but can also meet product and design requirements that involve 3D and spatial capabilities, making this way of **boosting development efficiency** can work for most use cases.

## Web 3D Developers {#3d-developers}

If you are a 3D developer, especially a Web 3D developer, your existing 3D skills now have **far more opportunities and a larger stage**.

Previously, these 3D skills could be used only in a limited number of 3D-game cases; and because traditional 3D apps on XR platforms occupy the entire space, you had to make the app support the entire user case on its own, fully satisfying the user's needs and driving retention and engagement by yourself. This resulted in high implementation costs and revenue pressure.

With WebSpatial, you can get involved in **the much broader, more user-friendly, commonly used Shared Space mode and multi-app environments**. In all spatial apps built on 2D GUI architecture, **every 3D container** becomes a stage for you to apply and show off your 3D dev skills. The 3D effects and content you create can **appear in more places, reach more users, and stay closer to them**.

You also **do not need to carry the entire user case alone** anymore. You can develop widgets, companion apps, helper tools, on-demand apps, social mini-games, and many other types of applications. They are inexpensive to build and quick to iterate, allowing you to **experiment with more ideas and meet more user needs**.

Even though WebSpatial v1 has not officially provided a 3D-engine API and the related 3D container yet, you can **still let your existing WebXR games benefit from WebSpatial**:

### WebXR Developers {#webxr-developers}

WebXR content is well suited to be used together with 2D web content. For example, GaaS (Games-as-a-Service) app's portal, lobby, item trading, and leaderboard features can all be implemented more efficiently and be more shareable in 2D webpages than through a 3D graphics API.

However, these 2D webpages were previously confined to flat windows with uniform backgrounds and borders, making them disjointed and inconsistent with the borderless WebXR content and limiting their capabilities. As soon as 3D content needed to be added, you had to switch from the webpage to WebXR session to implement it.

With WebSpatial, these **2D webpages that accompany WebXR games** can place UI in 3D space like WebXR content, embed true 3D content, and adopt a design language and theme similar to WebXR content, while still allowing the user to start a WebXR session with a single click. Users can **switch freely between WebXR mode and WebSpatial mode** at any time.

---

// File: introduction/index

# Introduction

This section introduces the problems WebSpatial solves and the benefits it brings.

import DocCardList from '@theme/DocCardList';

<DocCardList />

---

// File: quick-example/index

# Quick Example

Use a minimal example to get a quick feel for the actual results and development experience of the [WebSpatial SDK](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk), covering project setup, SDK installation and configuration, a sample development workflow, and a preview of spatial features.

:::warning

- This is NOT a development guide.
- To keep this example short and clear to quickly show real results, no explanations are given here.
- To make sure everything runs properly, please follow each step exactly - many of them are absolutely essential.
- This document includes detailed links, feel free to skip them for a quick example run.
- After you have completed the demo, you can dive into [the real development guide](/docs/development-guide/).

:::

:::tip

You can follow this doc to build the demo from scratch, or just grab the ready-made version from [the repo](https://github.com/webspatial/quick-example). You can also watch this video for a quick overview of everything in the doc:

<iframe
  style={{
    aspectRatio: "4/3",
    width: "100%",
    height: "auto"
  }}
  src="https://www.youtube.com/embed/UKx9EZtmtHU?si=kkfV71XSUwA-XW-_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

:::

## 1. Create a modern web project that supports WebSpatial {#create-project}

First confirm that Node.js is installed (see the [Node.js official website](https://nodejs.org/en/download)).

Using a standard React + Vite + TypeScript project as an example, run the following commands to create the project:

```bash npm2yarn
npx create-vite --template react-ts
```

:::tip
See [what kinds of web projects are considered WebSpatial-supported](/docs/development-guide/web-projects-that-support-webspatial) for details.
:::

After the above command is completed, navigate to the project root directory and install the dependencies:

```bash npm2yarn
cd YOUR_PROJECT_PATH
npm install
```

Then you can run the Dev Server to confirm everything works (remember to turn off this server before proceeding with the subsequent steps):

```bash npm2yarn
npm run dev
```

## 2. Install the WebSpatial SDK {#install-sdk}

Run the following commend under your project root:

> Check the [video tutorial at 0:26](https://www.youtube.com/watch?v=UKx9EZtmtHU&t=26s)

```bash npm2yarn
npm install --save @webspatial/react-sdk @webspatial/core-sdk @google/model-viewer three
npm install --save-dev @webspatial/builder @webspatial/platform-visionos @webspatial/vite-plugin vite-plugin-html
```

:::tip
See [which dependencies are installed](/docs/development-guide/enabling-webspatial-in-web-projects/step-1-install-the-webspatial-sdk) for details.
:::

## 3. Integrate the WebSpatial SDK into the web build tool (Vite) {#web-build-tool}

First modify `tsconfig.app.json` and `tsconfig.node.json`, adding the configuration that [affects JSX compilation](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/configure-js-ts-compiler).

```json5
{
  "compilerOptions": {
    // diff-add
    "jsxImportSource": "@webspatial/react-sdk",
```

Then modify `vite.config.ts`:

- Add [WebSpatial's Vite plugin](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/add-optimizations-and-defaults-to-web-build-tools).
- Inject the [environment variable `$XR_ENV`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode) into HTML.

```jsx
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
// diff-add
import webSpatial from "@webspatial/vite-plugin";
// diff-add
import { createHtmlPlugin } from "vite-plugin-html";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    // diff-add
    webSpatial(),
    // diff-add
    createHtmlPlugin({
      // diff-add
      inject: {
        // diff-add
        data: {
          // diff-add
          XR_ENV: process.env.XR_ENV,
          // diff-add
        },
        // diff-add
      },
      // diff-add
    }),
  ],
});
```

Run [the Dev Server for desktop/mobile and other non-XR platforms](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#regular-dev-server) (keep it running in the following steps):

```bash npm2yarn
npm run dev
```

<Image img={require("/assets/quick_v2/1.jpg")} alt="Scene Example 1"  width="100%"  />

Open the URL shown in the terminal in a desktop browser such as Chrome to confirm everything works:

<Image img={require("/assets/quick_v2/2.png")} alt="Scene Example 2" />

Next, open a new terminal window (in the project root) and run another Dev Server to generate [web code specifically for WebSpatial](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#dedicated-dev-server), used in the WebSpatial app on visionOS (keep it running in the following steps):

```bash npm2yarn
XR_ENV=avp npm run dev
```

<Image img={require("/assets/quick_v2/3.jpg")} alt="Scene Example 3" width="100%" />

## 4. Package and run the WebSpatial app {#package-and-run}

Before using [the packaging tool for WebSpatial](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps), install Xcode and the visionOS simulator:

:::tip
Prerequisite: a Mac computer

Steps:

1. Open the Mac App Store, search for "Xcode", and install it.
2. On first launch, agree to the license and enter the admin password to install additional components.
3. Click the top menu "Xcode" > "Settings…". In the "Components" tab, find visionOS and visionOS Simulator under "Platform Support", then install both.
   :::

Run the [development command (`run`)](/docs/development-guide/enabling-webspatial-in-web-projects/step-2-add-build-tool-for-packaged-webspatial-apps#run) of the packaging tool:

> Check the [video tutorial at 3:22](https://www.youtube.com/watch?v=UKx9EZtmtHU&t=202s)

```bash npm2yarn
npx webspatial-builder run --base=$XR_DEV_SERVER
```

:::warning
Replace `$XR_DEV_SERVER` with the URL generated by `XR_ENV=avp npm run dev` in the previous step.
For Example: The URL generated from Step 3 is:`http://localhost:5175/webspatial/avp`
You Should run: `npx webspatial-builder run --base=http://localhost:5175/webspatial/avp`
:::

The visionOS simulator will automatically launch, installs the [Packaged WebSpatial App](/docs/core-concepts/unique-concepts-in-webspatial#webspatial-sdk), and runs it:

<Image img={require("/assets/quick_v2/4.png")} alt="Scene Example 4" />
<Image img={require("/assets/quick_v2/5.png")} alt="Scene Example 5" />

## 5. Set initialization properties for the start scene {#start-scene}

Create a incomplete Web App Manifest file (this only works with the `webspatial-builder run` command, you'll need to [complete it before running on a real device or distributing it](/docs/development-guide/enabling-webspatial-in-web-projects/prerequisite-become-a-minimal-pwa)).

```bash
touch public/manifest.webmanifest
```

Set the [default size](/docs/core-concepts/scenes-and-spatial-layouts#spatial-layout) for the [start scene](/docs/core-concepts/scenes-and-spatial-layouts#start-scene) in [`xr_main_scene`](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes#start-scene).

```json5
{
  "xr_main_scene": {
    "default_size": {
      "width": 500,
      "height": 1000
    }
  }
}
```

Run the `run` command of the WebSpatial Builder again. The app's start scene now appears with a mobile app style:

:::note
A current bug may leave the start scene blank after repackaging. If this happens, delete the app in the simulator, quit the simulator, then package and run again.
If the issue persists, delete `node_modules` in the project and reinstall dependencies.
:::

<Image img={require("/assets/quick_v2/6.png")} alt="Scene Example 6" />

## 6. Add a new scene {#new-scene}

First add a new page. In this demo we use client-side routing.

Create `src/SecondPage.tsx`.

> Check [the sample code in GitHub for this step](https://github.com/webspatial/quick-example/blob/main/src/SecondPage.tsx) if you have any question about the code you need to add.


```jsx
import { useState } from "react";
import "./App.css";

function SecondPage() {
  const [count, setCount] = useState(0);

  return (
    <div className="App">
      <h1>Second Page</h1>
      <div className="card">
        <button onClick={() => setCount(count => count + 1)}>
          count is {count}
        </button>
      </div>
    </div>
  );
}

export default SecondPage;
```

Add the following to `src/App.tsx`.

```jsx
import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom";
import SecondPage from "./SecondPage";
```

Install a library that supports client-side routing.

```bash npm2yarn
npm install --save react-router-dom
```

Move all existing JSX in `src/App.tsx` into the designated position in the new JSX:

```jsx
  return (
    //diff-add
    <Router basename={__XR_ENV_BASE__}>
      //diff-add
      <Routes>
      //diff-add
        <Route path="/second-page" element={<SecondPage />} />
      //diff-add
        <Route
      //diff-add
          path="/"
      //diff-add
          element={
            /* Move all JSX from the App component in src/App.tsx into here */
      //diff-add
          }
      //diff-add
        />
      //diff-add
      </Routes>
      //diff-add
    </Router>
  );
```

:::tip
What is [`__XR_ENV_BASE__`](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website#use-dedicated-dev-server)?
:::

The new page `/second-page` has been added:

<Image img={require("/assets/quick_v2/7.png")} alt="Scene Example 7" />

At the end of the existing content in `src/App.tsx` (below `<p className="read-the-docs">`), add a card containing:

- A link that always opens `/second-page` in a new window.
- A button that opens `/second-page` in a window with [the specified `name`](/docs/development-guide/using-the-webspatial-api/manage-multiple-scenes#new-scene).

```jsx {4-19} showLineNumbers
              <p className="read-the-docs">
                Click on the Vite and React logos to learn more
              </p>
              <div className="card" style={{ marginTop: "0px" }}>
                <h2>Open Second Page</h2>
                <p>
                  <Link to="/second-page" target="_blank">
                    Open Second Page with a Link
                  </Link>
                </p>
                <p>
                  <button
                    onClick={() => {
                      window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
                    }}>
                    Open Second Page with a Button
                  </button>
                </p>
              </div>
```

Clicking the link or button opens a new [spatial-app scene](/docs/core-concepts/scenes-and-spatial-layouts) that displays the content of `/second-page`:

<video
  src="https://static.webspatial.dev/multi-scenes.mp4"
  autoPlay
  loop
  muted
  playsInline
  style={{ width: '100%', height: 'auto' }}
/>

## 7. Set initialization properties for the new scene {#init-scene}

Import the [scene initialization](/docs/core-concepts/scenes-and-spatial-layouts#scene-init) API from the WebSpatial SDK in `src/App.tsx`.

```jsx
import { initScene } from "@webspatial/react-sdk";
```

Before the scene named `"secondScene"` opens, initialize it:

```jsx {2-10} showLineNumbers
                    onClick={() => {
                      initScene("secondScene", prevConfig => {
                        return {
                          ...prevConfig,
                          defaultSize: {
                            width: 500,
                            height: 500,
                          },
                        };
                      });
                      window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
```

Click the button and see that the [default size](/docs/core-concepts/scenes-and-spatial-layouts#spatial-layout) of the `secondScene` scene changes:

<Image img={require("/assets/quick_v2/9.png")} alt="Scene Example 9" />

## 8. Add material backgrounds {#material-background}

Edit the `index.html` file to [add a special classname to the `<html>` element](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode#css-solution) when this web code is executed as a WebSpatial app ([`XR_ENV` mode](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/generate-a-webspatial-specific-website)).

<!-- prettier-ignore-start -->
```html
//diff-add
<%- XR_ENV === 'avp' ? `
//diff-add
  <html lang="en" class="is-spatial">
//diff-add
  ` : `
    <html lang="en">
//diff-add
    ` %>
```
<!-- prettier-ignore-end -->

At the end of `src/index.css`, add code that sets the scene background in `XR_ENV` mode to a [fully transparent material](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds) (using `--xr-background-material` from the WebSpatial API):

```css
html.is-spatial {
  background-color: transparent;
  --xr-background-material: transparent;
}
```

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/10.png")} alt="" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/11.png")} alt="" />
  </div>
</div>

:::tip
Although style changes take effect automatically via the Dev Server, but since the WebSpatial SDK doesn't yet support HMR for specific logic inside React components, you'll need to manually refresh the page (using the [scene menu](/docs/core-concepts/scenes-and-spatial-layouts#scene-menu)) or restart the devServer to apply those changes.
:::

Modify `src/App.tsx` to make both card elements ["spatialized HTML elements"](/docs/core-concepts/spatialized-elements-and-3d-container-elements) by adding [a specific mark](/docs/development-guide/using-the-webspatial-api/spatialize-html-elements), and give them different classnames. Spatialize the link inside `link-card` as well.

```jsx
              <h1>Vite + React</h1>
              //diff-remove
              <div className="card">
              //diff-add
              <div className="card count-card" enable-xr>
```

```jsx
              //diff-remove
              <div className="card">
              //diff-add
              <div className="card link-card" enable-xr>
                <h2>Open Second Page</h2>
                <p>
              //diff-remove
                  <a href="/second-page" target="_blank">
              //diff-add
                  <a href="/second-page" target="_blank" enable-xr>
                    Open Second Page with a Link
                  </a>
```

In the [styles for `XR_ENV` mode](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode#css-solution) in `src/index.css`, set [different translucent materials](/docs/development-guide/using-the-webspatial-api/add-material-backgrounds#translucent-options) for the backgrounds of the two card elements and the link.

```css
html.is-spatial {
  background-color: transparent;
  --xr-background-material: transparent;

  .count-card {
    --xr-background-material: thick;
    position: relative;
  }

  .link-card {
    --xr-background-material: translucent;
    border-radius: 20px;
    position: relative;
    top: 20px;

    a {
      display: block;
      --xr-background-material: thick;
      border-radius: 10px;
    }
  }
}
```

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/12.png")} alt="" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/13.png")} alt="" />
  </div>
</div>

## 9. Elevate spatialized elements {#elevation}

In `src/App.tsx`, mark the description text inside `count-card` as a [spatialized HTML element](/docs/core-concepts/spatialized-elements-and-3d-container-elements).

```jsx
//diff-remove
                <p>
//diff-add
                <p enable-xr>
                  Edit <code>src/App.tsx</code> and save to test HMR
                </p>
```

In the [styles for `XR_ENV` mode](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode#css-solution) in `src/index.css`, change this element to `position: relative` and use the WebSpatial's [Z-axis positioning API (`--xr-back`)](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements) to "elevate" it into 3D space in front of the web page plane. Also apply different levels of 'elevation' to the link elements spatialized earlier.

```css {5-12,19} showLineNumbers
  .count-card {
    --xr-background-material: thick;
    position: relative;

    p {
      --xr-background-material: transparent;
      position: absolute;
      bottom: -10px;
      left: 0;
      right: 0;
      --xr-back: 20;
    }
  }

  .link-card {
    --xr-background-material: translucent;
    border-radius: 20px;
    position: relative;
    --xr-back: 50;
    top: 20px;
```

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/14.png")} alt="" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/15.png")} alt="" />
  </div>
</div>

Another way to "elevate" is to [use CSS Transform](/docs/development-guide/using-the-webspatial-api/elevate-2d-elements#css-transform), which can also [deform and rotate](/docs/introduction/make-the-web-spatial-too#transform) in 3D space.

In the [styles for `XR_ENV` mode](/docs/development-guide/enabling-webspatial-in-web-projects/step-3-integrate-webspatial-sdk-into-web-build-tools/check-if-running-in-webspatial-mode#css-solution) in `src/index.css`, move and rotate `link-card` along the Z axis (around the X axis):

```css
  .link-card {
    --xr-background-material: translucent;
    border-radius: 20px;
    position: relative;
    --xr-back: 50;
    top: 20px;
    //diff-add
    transform-origin: top left;
//diff-add
    transform: translateZ(30px) rotateX(30deg);
```

<div className="row">
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/16.png")} alt="" />
  </div>
  <div className="col col--6">
    <Image img={require("/assets/quick_v2/17.png")} alt="" />
  </div>
</div>

## 10. Add static 3D content {#static-3d}

> To be added

## Final result {#final-result}

The full source code for this demo is in the repository:

https://github.com/webspatial/quick-example

You can either follow the steps in this article to build an identical demo project from scratch, or just clone the repo and run it using the README instructions.